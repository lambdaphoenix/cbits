<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cbits: src/python/bitvector_methods_slice.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cbits<span id="projectnumber">&#160;0.3.0</span>
   </div>
   <div id="projectbrief">High-performance BitVector C-API &amp; Python binding</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_5c0d64f70903e893b1efe571a4b8de29.html">python</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bitvector_methods_slice.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Slicing support for the <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> Python type.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="bitvector__methods__slice_8h_source.html">bitvector_methods_slice.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="bitvector__object_8h_source.html">bitvector_object.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bitvector_methods_slice.c:</div>
<div class="dyncontent">
<div class="center"><img src="bitvector__methods__slice_8c__incl.png" border="0" usemap="#asrc_2python_2bitvector__methods__slice_8c" alt=""/></div>
<map name="asrc_2python_2bitvector__methods__slice_8c" id="asrc_2python_2bitvector__methods__slice_8c">
<area shape="rect" title="Slicing support for the BitVector Python type." alt="" coords="93,5,245,45"/>
<area shape="rect" href="bitvector__methods__slice_8h.html" title="Slicing support for BitVector." alt="" coords="5,93,199,119"/>
<area shape="poly" title=" " alt="" coords="155,47,123,84,119,81,151,44"/>
<area shape="rect" href="bitvector__object_8h.html" title="Definition of the PyBitVector Python type." alt="" coords="99,167,238,192"/>
<area shape="poly" title=" " alt="" coords="188,44,209,78,214,99,213,119,203,140,191,158,186,155,199,137,207,118,209,99,204,80,184,47"/>
<area shape="poly" title=" " alt="" coords="115,117,150,155,147,158,111,121"/>
<area shape="rect" title=" " alt="" coords="77,387,156,412"/>
<area shape="poly" title=" " alt="" coords="151,194,126,214,106,241,96,275,96,311,102,345,110,373,105,374,97,346,91,311,91,274,101,239,122,210,148,190"/>
<area shape="rect" href="bitvector__internal_8h.html" title="Internal inline helpers for BitVector operations." alt="" coords="245,240,394,265"/>
<area shape="poly" title=" " alt="" coords="194,190,283,232,281,236,192,194"/>
<area shape="rect" href="cbits__state_8h.html" title="Module&#45;local state for the cbits extension." alt="" coords="116,240,221,265"/>
<area shape="poly" title=" " alt="" coords="171,192,171,226,166,226,166,192"/>
<area shape="rect" href="bitvector_8h.html" title="Public C API for the BitVector data structure." alt="" coords="274,313,365,339"/>
<area shape="poly" title=" " alt="" coords="322,266,322,300,317,300,317,266"/>
<area shape="rect" title=" " alt="" coords="442,460,517,485"/>
<area shape="poly" title=" " alt="" coords="366,335,413,353,436,367,456,385,473,414,480,445,475,446,468,416,452,388,433,371,411,358,364,340"/>
<area shape="rect" title=" " alt="" coords="216,460,287,485"/>
<area shape="poly" title=" " alt="" coords="295,341,266,360,253,373,243,388,239,402,238,417,244,447,239,448,233,418,233,401,238,386,249,370,263,356,292,337"/>
<area shape="rect" title=" " alt="" coords="253,387,335,412"/>
<area shape="poly" title=" " alt="" coords="318,340,305,375,300,373,313,338"/>
<area shape="rect" href="compat_8h.html" title="Cross&#45;platform aligned allocators, popcount, prefetch." alt="" coords="359,387,442,412"/>
<area shape="poly" title=" " alt="" coords="334,337,379,376,375,380,331,341"/>
<area shape="poly" title=" " alt="" coords="415,410,458,449,455,453,412,414"/>
<area shape="poly" title=" " alt="" coords="378,414,289,456,287,452,376,410"/>
<area shape="rect" title=" " alt="" coords="347,460,417,485"/>
<area shape="poly" title=" " alt="" coords="400,413,391,448,386,446,395,412"/>
<area shape="rect" href="cbits__module_8h.html" title="Forward declaration of the cbits module definition." alt="" coords="112,313,233,339"/>
<area shape="poly" title=" " alt="" coords="172,266,174,300,169,300,167,266"/>
<area shape="poly" title=" " alt="" coords="166,341,136,377,132,374,161,337"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5b58e4945ffe3970dd522330d9690137" id="r_a5b58e4945ffe3970dd522330d9690137"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvector__methods__slice_8c.html#a5b58e4945ffe3970dd522330d9690137">py_bitvector_get_item</a> (PyObject *object, Py_ssize_t i)</td></tr>
<tr class="memdesc:a5b58e4945ffe3970dd522330d9690137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boolean value of a single bit.  <br /></td></tr>
<tr class="separator:a5b58e4945ffe3970dd522330d9690137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367056829ebc427ffe70156edb1b36ca" id="r_a367056829ebc427ffe70156edb1b36ca"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvector__methods__slice_8c.html#a367056829ebc427ffe70156edb1b36ca">py_bitvector_item</a> (PyObject *object, Py_ssize_t i)</td></tr>
<tr class="memdesc:a367056829ebc427ffe70156edb1b36ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__getitem__, returns the bit at position i.  <br /></td></tr>
<tr class="separator:a367056829ebc427ffe70156edb1b36ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8470ed66918b13e9b80f4daeefa750" id="r_a1e8470ed66918b13e9b80f4daeefa750"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvector__methods__slice_8c.html#a1e8470ed66918b13e9b80f4daeefa750">py_bitvector_ass_item</a> (PyObject *object, Py_ssize_t i, PyObject *value)</td></tr>
<tr class="memdesc:a1e8470ed66918b13e9b80f4daeefa750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__setitem__ for a single index.  <br /></td></tr>
<tr class="separator:a1e8470ed66918b13e9b80f4daeefa750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d86cf4e076f000e04f076c9e509e82" id="r_a75d86cf4e076f000e04f076c9e509e82"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvector__methods__slice_8c.html#a75d86cf4e076f000e04f076c9e509e82">py_bitvector_slice</a> (PyObject *object, size_t start, size_t stop, size_t step, size_t slicelength)</td></tr>
<tr class="memdesc:a75d86cf4e076f000e04f076c9e509e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements slicing for BitVector.__getitem__ with a slice object.  <br /></td></tr>
<tr class="separator:a75d86cf4e076f000e04f076c9e509e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5479fbaa743e76fc27d5885a4ce2847" id="r_ad5479fbaa743e76fc27d5885a4ce2847"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvector__methods__slice_8c.html#ad5479fbaa743e76fc27d5885a4ce2847">py_bitvector_ass_slice</a> (PyObject *self, size_t start, size_t stop, size_t step, size_t slicelength, PyObject *value)</td></tr>
<tr class="memdesc:ad5479fbaa743e76fc27d5885a4ce2847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__setitem__ for slice assignment.  <br /></td></tr>
<tr class="separator:ad5479fbaa743e76fc27d5885a4ce2847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab059d2d7ca82ba4bf032e17ea4590a8b" id="r_ab059d2d7ca82ba4bf032e17ea4590a8b"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvector__methods__slice_8c.html#ab059d2d7ca82ba4bf032e17ea4590a8b">py_bitvector_subscript</a> (PyObject *object, PyObject *arg)</td></tr>
<tr class="memdesc:ab059d2d7ca82ba4bf032e17ea4590a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__getitem__ dispatch for index or slice.  <br /></td></tr>
<tr class="separator:ab059d2d7ca82ba4bf032e17ea4590a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d0fbf2c1187d6ac335d37f0b912590" id="r_a78d0fbf2c1187d6ac335d37f0b912590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitvector__methods__slice_8c.html#a78d0fbf2c1187d6ac335d37f0b912590">py_bitvector_ass_subscript</a> (PyObject *object, PyObject *arg, PyObject *value)</td></tr>
<tr class="memdesc:a78d0fbf2c1187d6ac335d37f0b912590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__setitem__ dispatch for index or slice.  <br /></td></tr>
<tr class="separator:a78d0fbf2c1187d6ac335d37f0b912590"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Slicing support for the <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> Python type. </p>
<p>Implements <b>getitem</b> and <b>setitem</b> for slice objects as well as integer indexing. Slice extraction uses fast bit‑shifting paths for contiguous ranges and falls back to per‑bit copying for stepped slices. Slice assignment accepts any iterable of truthy values and writes them into the target range.</p>
<dl class="section author"><dt>Author</dt><dd>lambdaphoenix </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.3.0 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2026 lambdaphoenix </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1e8470ed66918b13e9b80f4daeefa750" name="a1e8470ed66918b13e9b80f4daeefa750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8470ed66918b13e9b80f4daeefa750">&#9670;&#160;</a></span>py_bitvector_ass_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int py_bitvector_ass_item </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Py_ssize_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements BitVector.__setitem__ for a single index. </p>
<p>Sets or clears the bit at position i based on the truth value of <code>value</code>. Raises IndexError if the index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>A Python <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> instance. </td></tr>
    <tr><td class="paramname">i</td><td>Index of the bit to assign. </td></tr>
    <tr><td class="paramname">value</td><td>Python object interpreted as boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 on error (with exception set). </dd></dl>

</div>
</div>
<a id="ad5479fbaa743e76fc27d5885a4ce2847" name="ad5479fbaa743e76fc27d5885a4ce2847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5479fbaa743e76fc27d5885a4ce2847">&#9670;&#160;</a></span>py_bitvector_ass_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bitvector_ass_slice </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slicelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements BitVector.__setitem__ for slice assignment. </p>
<p>Assigns bits from an iterable <code>value</code> to the slice [start:stop:step]. Raises IndexError or ValueError on length mismatch or out-of-range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> instance. </td></tr>
    <tr><td class="paramname">start</td><td>Start index of the slice. </td></tr>
    <tr><td class="paramname">stop</td><td>End index (exclusive) of the slice. </td></tr>
    <tr><td class="paramname">step</td><td>Step size for the slice. </td></tr>
    <tr><td class="paramname">slicelength</td><td>Number of elements in the resulting slice. </td></tr>
    <tr><td class="paramname">value</td><td>Iterable of boolean-convertible Python objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 on error (with exception set). </dd></dl>

</div>
</div>
<a id="a78d0fbf2c1187d6ac335d37f0b912590" name="a78d0fbf2c1187d6ac335d37f0b912590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d0fbf2c1187d6ac335d37f0b912590">&#9670;&#160;</a></span>py_bitvector_ass_subscript()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int py_bitvector_ass_subscript </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements BitVector.__setitem__ dispatch for index or slice. </p>
<p>Delegates to py_bitvector_ass_item or py_bitvector_ass_slice depending on type of <code>arg</code>. Does not support item deletion (value==NULL).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Index or slice object. </td></tr>
    <tr><td class="paramname">value</td><td>Python object to assign (must not be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 on error (with exception set). </dd></dl>

</div>
</div>
<a id="a5b58e4945ffe3970dd522330d9690137" name="a5b58e4945ffe3970dd522330d9690137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b58e4945ffe3970dd522330d9690137">&#9670;&#160;</a></span>py_bitvector_get_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bitvector_get_item </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Py_ssize_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the boolean value of a single bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>A Python <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> instance. </td></tr>
    <tr><td class="paramname">i</td><td>Index to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New reference to Py_True or Py_False</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.3.0 </dd></dl>

</div>
</div>
<a id="a367056829ebc427ffe70156edb1b36ca" name="a367056829ebc427ffe70156edb1b36ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367056829ebc427ffe70156edb1b36ca">&#9670;&#160;</a></span>py_bitvector_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject * py_bitvector_item </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Py_ssize_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements BitVector.__getitem__, returns the bit at position i. </p>
<p>This function checks bounds and returns the corresponding Python boolean (True/False). On out-of-range access it raises IndexError.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>A Python <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> instance. </td></tr>
    <tr><td class="paramname">i</td><td>Index to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New reference to Py_True or Py_False on success; NULL and IndexError on failure. </dd></dl>

</div>
</div>
<a id="a75d86cf4e076f000e04f076c9e509e82" name="a75d86cf4e076f000e04f076c9e509e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d86cf4e076f000e04f076c9e509e82">&#9670;&#160;</a></span>py_bitvector_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bitvector_slice </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slicelength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements slicing for BitVector.__getitem__ with a slice object. </p>
<p>Creates and returns a new <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> containing eleme nts from [start:stop:step]. Raises IndexError if any index is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>A Python <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> instance. </td></tr>
    <tr><td class="paramname">start</td><td>Start index of the slice. </td></tr>
    <tr><td class="paramname">stop</td><td>End index (exclusive) of the slice. </td></tr>
    <tr><td class="paramname">step</td><td>Step size for the slice. </td></tr>
    <tr><td class="paramname">slicelength</td><td>Number of elements in the resulting slice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> wrapping the sliced <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>; NULL and IndexError on failure. </dd></dl>

</div>
</div>
<a id="ab059d2d7ca82ba4bf032e17ea4590a8b" name="ab059d2d7ca82ba4bf032e17ea4590a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab059d2d7ca82ba4bf032e17ea4590a8b">&#9670;&#160;</a></span>py_bitvector_subscript()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject * py_bitvector_subscript </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements BitVector.__getitem__ dispatch for index or slice. </p>
<p>Delegates either to py_bitvector_item (for integer indices) or to py_bitvector_slice (for slice objects). Raises TypeError for unsupported types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Index or slice object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New reference to a Python bool or <a class="el" href="structPyBitVectorObject.html" title="Python object containing a pointer to a native BitVector.">PyBitVectorObject</a>; NULL and exception on error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 10 2026 02:25:23 for cbits by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
