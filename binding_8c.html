<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cbits: python/binding.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">cbits<span id="projectnumber">&#160;0.2.0</span>
   </div>
   <div id="projectbrief">High-performance BitVector C-API &amp; Python binding</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7837fde3ab9c1fb2fc5be7b717af8d79.html">python</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">binding.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Python C-API bindings for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;Python.h&gt;</code><br />
<code>#include &quot;<a class="el" href="bitvector_8h_source.html">bitvector.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for binding.c:</div>
<div class="dyncontent">
<div class="center"><img src="binding_8c__incl.png" border="0" usemap="#apython_2binding_8c" alt=""/></div>
<map name="apython_2binding_8c" id="apython_2binding_8c">
<area shape="rect" title="Python C&#45;API bindings for BitVector." alt="" coords="71,5,202,31"/>
<area shape="rect" title=" " alt="" coords="43,79,121,104"/>
<area shape="poly" title=" " alt="" coords="130,33,101,69,97,66,126,29"/>
<area shape="rect" href="bitvector_8h.html" title="Packed BitVector C&#45;API declarations." alt="" coords="146,79,237,104"/>
<area shape="poly" title=" " alt="" coords="148,29,176,66,172,69,144,33"/>
<area shape="rect" href="compat_8h.html" title="Cross&#45;platform aligned allocators, popcount, prefetch." alt="" coords="97,152,179,177"/>
<area shape="poly" title=" " alt="" coords="185,106,157,143,153,140,180,103"/>
<area shape="rect" title=" " alt="" coords="203,152,286,177"/>
<area shape="poly" title=" " alt="" coords="202,103,230,140,226,143,198,106"/>
<area shape="rect" title=" " alt="" coords="5,225,76,251"/>
<area shape="poly" title=" " alt="" coords="124,180,69,219,66,215,121,175"/>
<area shape="rect" title=" " alt="" coords="101,225,175,251"/>
<area shape="poly" title=" " alt="" coords="141,178,141,212,135,212,135,178"/>
<area shape="rect" title=" " alt="" coords="200,225,271,251"/>
<area shape="poly" title=" " alt="" coords="155,175,210,215,207,219,152,180"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPyBitVector.html">PyBitVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python object containing a pointer to a native <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <a href="structPyBitVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPyBitVectorIter.html">PyBitVectorIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator structure for <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a>.  <a href="structPyBitVectorIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac9efdaac9411d0868b715edccca3269d" id="r_ac9efdaac9411d0868b715edccca3269d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ac9efdaac9411d0868b715edccca3269d">PY_SSIZE_T_CLEAN</a></td></tr>
<tr class="separator:ac9efdaac9411d0868b715edccca3269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db76aaaed3680d17b24435989491b21" id="r_a1db76aaaed3680d17b24435989491b21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a1db76aaaed3680d17b24435989491b21">CHECK_BV_OBJ</a>(o)</td></tr>
<tr class="memdesc:a1db76aaaed3680d17b24435989491b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <em>o</em> is a <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance or raise <code>TypeError</code>.  <br /></td></tr>
<tr class="separator:a1db76aaaed3680d17b24435989491b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1146a73d52acb0776f13d2d43954d0" id="r_a3a1146a73d52acb0776f13d2d43954d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a3a1146a73d52acb0776f13d2d43954d0">CHECK_BV_BOTH</a>(a,  b)</td></tr>
<tr class="memdesc:a3a1146a73d52acb0776f13d2d43954d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify both <em>a</em> and <em>b</em> are <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a>, else return <code>NotImplemented</code>.  <br /></td></tr>
<tr class="separator:a3a1146a73d52acb0776f13d2d43954d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13fba70d68d647dc3c308c0be92240" id="r_a7b13fba70d68d647dc3c308c0be92240"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a7b13fba70d68d647dc3c308c0be92240">ADD_OBJECT</a>(module,  name,  object)</td></tr>
<tr class="memdesc:a7b13fba70d68d647dc3c308c0be92240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a PyObject to a module, handling reference counts portably.  <br /></td></tr>
<tr class="separator:a7b13fba70d68d647dc3c308c0be92240"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5e6fffc9d5f721ba9836bdc7c173499a" id="r_a5e6fffc9d5f721ba9836bdc7c173499a"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a5e6fffc9d5f721ba9836bdc7c173499a">bv_wrap_new</a> (<a class="el" href="structBitVector.html">BitVector</a> *bv_data)</td></tr>
<tr class="memdesc:a5e6fffc9d5f721ba9836bdc7c173499a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a native <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> in a new <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> Python object.  <br /></td></tr>
<tr class="separator:a5e6fffc9d5f721ba9836bdc7c173499a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d55c861d7fdf3b0e9b95497fdb6a6e4" id="r_a2d55c861d7fdf3b0e9b95497fdb6a6e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a2d55c861d7fdf3b0e9b95497fdb6a6e4">py_bv_free</a> (PyObject *self)</td></tr>
<tr class="memdesc:a2d55c861d7fdf3b0e9b95497fdb6a6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate a <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> object.  <br /></td></tr>
<tr class="separator:a2d55c861d7fdf3b0e9b95497fdb6a6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33699ee8e583f6b69da8d7a4b011de12" id="r_a33699ee8e583f6b69da8d7a4b011de12"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a33699ee8e583f6b69da8d7a4b011de12">py_bv_new</a> (PyTypeObject *type, PyObject *args, PyObject *kwds)</td></tr>
<tr class="memdesc:a33699ee8e583f6b69da8d7a4b011de12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>new</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>: allocate the Python object.  <br /></td></tr>
<tr class="separator:a33699ee8e583f6b69da8d7a4b011de12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c5804ed6745718be7527a3aae4664a" id="r_a67c5804ed6745718be7527a3aae4664a"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a67c5804ed6745718be7527a3aae4664a">py_bv_copy</a> (PyObject *self, PyObject *ignored)</td></tr>
<tr class="memdesc:a67c5804ed6745718be7527a3aae4664a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.copy() → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a67c5804ed6745718be7527a3aae4664a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5569e465c62a44515af6f4aa324fc60" id="r_ad5569e465c62a44515af6f4aa324fc60"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ad5569e465c62a44515af6f4aa324fc60">py_bv_deepcopy</a> (PyObject *self, PyObject *memo)</td></tr>
<tr class="memdesc:ad5569e465c62a44515af6f4aa324fc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.__deepcopy__(memo) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:ad5569e465c62a44515af6f4aa324fc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510d7b30401e3d3bd188a9a7de61803d" id="r_a510d7b30401e3d3bd188a9a7de61803d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a510d7b30401e3d3bd188a9a7de61803d">py_bv_init</a> (PyObject *self, PyObject *args, PyObject *kwds)</td></tr>
<tr class="memdesc:a510d7b30401e3d3bd188a9a7de61803d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>init</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector(size)</a>: allocate the underlying C <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a510d7b30401e3d3bd188a9a7de61803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f1d18ed7869c72e4d5e383af06f48f" id="r_a66f1d18ed7869c72e4d5e383af06f48f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a66f1d18ed7869c72e4d5e383af06f48f">bv_parse_index</a> (PyObject *self, PyObject *arg, size_t *p_index)</td></tr>
<tr class="memdesc:a66f1d18ed7869c72e4d5e383af06f48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and validate a single index argument.  <br /></td></tr>
<tr class="separator:a66f1d18ed7869c72e4d5e383af06f48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83d6c14dbf421173b34f8b69d00da95" id="r_af83d6c14dbf421173b34f8b69d00da95"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#af83d6c14dbf421173b34f8b69d00da95">bv_parse_tuple</a> (PyObject *self, PyObject *args, size_t *p_start, size_t *p_len)</td></tr>
<tr class="memdesc:af83d6c14dbf421173b34f8b69d00da95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and validate a (start, length) range tuple.  <br /></td></tr>
<tr class="separator:af83d6c14dbf421173b34f8b69d00da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f4a245c9973679b1f9af1379e81821" id="r_a95f4a245c9973679b1f9af1379e81821"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a95f4a245c9973679b1f9af1379e81821">py_bv_get</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:a95f4a245c9973679b1f9af1379e81821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.get(index) → bool.  <br /></td></tr>
<tr class="separator:a95f4a245c9973679b1f9af1379e81821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83289c5959b0cbc9ef594a00054b3d0a" id="r_a83289c5959b0cbc9ef594a00054b3d0a"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a83289c5959b0cbc9ef594a00054b3d0a">py_bv_set</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:a83289c5959b0cbc9ef594a00054b3d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.set(index).  <br /></td></tr>
<tr class="separator:a83289c5959b0cbc9ef594a00054b3d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d93df3d5ac6faaa1366b7f31402798" id="r_af3d93df3d5ac6faaa1366b7f31402798"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#af3d93df3d5ac6faaa1366b7f31402798">py_bv_clear</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:af3d93df3d5ac6faaa1366b7f31402798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.clear(index).  <br /></td></tr>
<tr class="separator:af3d93df3d5ac6faaa1366b7f31402798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c1503708121705e22921b48fabf14c" id="r_a38c1503708121705e22921b48fabf14c"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a38c1503708121705e22921b48fabf14c">py_bv_flip</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:a38c1503708121705e22921b48fabf14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.flip(index).  <br /></td></tr>
<tr class="separator:a38c1503708121705e22921b48fabf14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a36766609fe6f9a6f7b436d305d29cd" id="r_a5a36766609fe6f9a6f7b436d305d29cd"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a5a36766609fe6f9a6f7b436d305d29cd">py_bv_set_range</a> (PyObject *self, PyObject *args)</td></tr>
<tr class="memdesc:a5a36766609fe6f9a6f7b436d305d29cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.set_range(start, length).  <br /></td></tr>
<tr class="separator:a5a36766609fe6f9a6f7b436d305d29cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac489bee1773936cb5e811e2d0252707f" id="r_ac489bee1773936cb5e811e2d0252707f"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ac489bee1773936cb5e811e2d0252707f">py_bv_clear_range</a> (PyObject *self, PyObject *args)</td></tr>
<tr class="memdesc:ac489bee1773936cb5e811e2d0252707f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.clear_range(start, length).  <br /></td></tr>
<tr class="separator:ac489bee1773936cb5e811e2d0252707f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa5a8a1af4ebbd29f13a650c21f3af2" id="r_abaa5a8a1af4ebbd29f13a650c21f3af2"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#abaa5a8a1af4ebbd29f13a650c21f3af2">py_bv_flip_range</a> (PyObject *self, PyObject *args)</td></tr>
<tr class="memdesc:abaa5a8a1af4ebbd29f13a650c21f3af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.flip_range(start, length).  <br /></td></tr>
<tr class="separator:abaa5a8a1af4ebbd29f13a650c21f3af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6596d7e4e07e24155651258c9091028b" id="r_a6596d7e4e07e24155651258c9091028b"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a6596d7e4e07e24155651258c9091028b">py_bv_rank</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:a6596d7e4e07e24155651258c9091028b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python binding for BitVector.rank(index) → bool.  <br /></td></tr>
<tr class="separator:a6596d7e4e07e24155651258c9091028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4f1973576a28570505fd8ebe44de7f" id="r_a4f4f1973576a28570505fd8ebe44de7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a4f4f1973576a28570505fd8ebe44de7f">PyDoc_STRVAR</a> (py_bv_get__doc__, &quot;get(index: int) -&gt; bool\n&quot; &quot;\n&quot; &quot;Return the boolean value of the bit at position *index*.\n&quot; &quot;Negative indices are supported. Raises IndexError if out of range.&quot;)</td></tr>
<tr class="separator:a4f4f1973576a28570505fd8ebe44de7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051fef147d43e118d591720c1ade81a7" id="r_a051fef147d43e118d591720c1ade81a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a051fef147d43e118d591720c1ade81a7">PyDoc_STRVAR</a> (py_bv_set__doc__, &quot;set(index: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Set the bit at position *index* to True. Supports negative indexing.\n&quot; &quot;Raises IndexError if out of range.&quot;)</td></tr>
<tr class="separator:a051fef147d43e118d591720c1ade81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fec1a34b42e4faa10468e1b05d5a2a" id="r_a68fec1a34b42e4faa10468e1b05d5a2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a68fec1a34b42e4faa10468e1b05d5a2a">PyDoc_STRVAR</a> (py_bv_clear__doc__, &quot;clear(index: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Clear the bit (set to False) at position *index*. Supports &quot; &quot;negative indexing.\n&quot; &quot;Raises IndexError if out of range.&quot;)</td></tr>
<tr class="separator:a68fec1a34b42e4faa10468e1b05d5a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0168cda7bd3f2cbff1aa141999f47c7f" id="r_a0168cda7bd3f2cbff1aa141999f47c7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a0168cda7bd3f2cbff1aa141999f47c7f">PyDoc_STRVAR</a> (py_bv_set_range__doc__, &quot;set_range(start: int, length: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Set all bits in the half-open range [start, start+length).\n&quot; &quot;Raises IndexError if the range is out of bounds.&quot;)</td></tr>
<tr class="separator:a0168cda7bd3f2cbff1aa141999f47c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab955783023262da680c8bcb054ba1963" id="r_ab955783023262da680c8bcb054ba1963"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ab955783023262da680c8bcb054ba1963">PyDoc_STRVAR</a> (py_bv_clear_range__doc__, &quot;clear_range(start: int, length: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Clear all bits in the half-open range [start, start+length).\n&quot; &quot;Raises IndexError if the range is out of bounds.&quot;)</td></tr>
<tr class="separator:ab955783023262da680c8bcb054ba1963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43697e8ed705eb2f0b49517a3c533aa" id="r_ae43697e8ed705eb2f0b49517a3c533aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ae43697e8ed705eb2f0b49517a3c533aa">PyDoc_STRVAR</a> (py_bv_flip_range__doc__, &quot;flip_range(start: int, length: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Toggle all bits in the half-open range [start, start+length).\n&quot; &quot;Raises IndexError if the range is out of bounds.&quot;)</td></tr>
<tr class="separator:ae43697e8ed705eb2f0b49517a3c533aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb4bf04b7dba5886d67076d40167328" id="r_aeeb4bf04b7dba5886d67076d40167328"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#aeeb4bf04b7dba5886d67076d40167328">PyDoc_STRVAR</a> (py_bv_flip__doc__, &quot;flip(index: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Toggle the bit at position *index*. Supports negative indexing.\n&quot; &quot;Raises IndexError if out of range.&quot;)</td></tr>
<tr class="separator:aeeb4bf04b7dba5886d67076d40167328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc62d1304007fadd932f46d3952167e" id="r_affc62d1304007fadd932f46d3952167e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#affc62d1304007fadd932f46d3952167e">PyDoc_STRVAR</a> (py_bv_rank__doc__, &quot;rank(index: int) -&gt; int\n&quot; &quot;\n&quot; &quot;Count the number of bits set to True in the half-open range [0..index].\n&quot; &quot;Supports negative indexing. Raises IndexError if out of range.&quot;)</td></tr>
<tr class="separator:affc62d1304007fadd932f46d3952167e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c7189ce65be48e710bd5fa5a03f87" id="r_a1c3c7189ce65be48e710bd5fa5a03f87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a1c3c7189ce65be48e710bd5fa5a03f87">PyDoc_STRVAR</a> (py_bv_copy__doc__, &quot;copy() -&gt; BitVector\n&quot; &quot;\n&quot; &quot;Return a copy of this BitVector.&quot;)</td></tr>
<tr class="separator:a1c3c7189ce65be48e710bd5fa5a03f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadde30ba5221d4e50c79f97e995ee9cd" id="r_aadde30ba5221d4e50c79f97e995ee9cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#aadde30ba5221d4e50c79f97e995ee9cd">PyDoc_STRVAR</a> (py_bv_copy_inline__doc__, &quot;__copy__() -&gt; BitVector\n&quot; &quot;\n&quot; &quot;Return a copy of this BitVector.&quot;)</td></tr>
<tr class="separator:aadde30ba5221d4e50c79f97e995ee9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4f67838cd25681435f80de1ac59357" id="r_aeb4f67838cd25681435f80de1ac59357"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#aeb4f67838cd25681435f80de1ac59357">PyDoc_STRVAR</a> (py_bv_deepcopy__doc__, &quot;__deepcopy__(memo: dict) -&gt; BitVector\n&quot; &quot;\n&quot; &quot;Return a copy of this <a class="el" href="structBitVector.html">BitVector</a>, registering it in *memo*.&quot;)</td></tr>
<tr class="separator:aeb4f67838cd25681435f80de1ac59357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c29dda376c942eaafd3e1297c392b6c" id="r_a7c29dda376c942eaafd3e1297c392b6c"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a7c29dda376c942eaafd3e1297c392b6c">py_bv_repr</a> (PyObject *self)</td></tr>
<tr class="memdesc:a7c29dda376c942eaafd3e1297c392b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>repr</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a7c29dda376c942eaafd3e1297c392b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bbcefc5bea6072787075f0a7e305c8" id="r_a08bbcefc5bea6072787075f0a7e305c8"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a08bbcefc5bea6072787075f0a7e305c8">py_bv_str</a> (PyObject *self)</td></tr>
<tr class="memdesc:a08bbcefc5bea6072787075f0a7e305c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>str</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a08bbcefc5bea6072787075f0a7e305c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907d626799062d832d366b69aa7755ef" id="r_a907d626799062d832d366b69aa7755ef"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a907d626799062d832d366b69aa7755ef">py_bv_richcompare</a> (PyObject *a, PyObject *b, int op)</td></tr>
<tr class="memdesc:a907d626799062d832d366b69aa7755ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rich comparison (== and !=) for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a907d626799062d832d366b69aa7755ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f67615df466f74b6f90c13dc37589ff" id="r_a2f67615df466f74b6f90c13dc37589ff"><td class="memItemLeft" align="right" valign="top">static Py_hash_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a2f67615df466f74b6f90c13dc37589ff">py_bv_hash</a> (PyObject *self)</td></tr>
<tr class="memdesc:a2f67615df466f74b6f90c13dc37589ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>hash</b> for a <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> object.  <br /></td></tr>
<tr class="separator:a2f67615df466f74b6f90c13dc37589ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e08dec927792701cb73c6e6a1df927" id="r_a21e08dec927792701cb73c6e6a1df927"><td class="memItemLeft" align="right" valign="top">static Py_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a21e08dec927792701cb73c6e6a1df927">py_bv_len</a> (PyObject *self)</td></tr>
<tr class="memdesc:a21e08dec927792701cb73c6e6a1df927"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>len</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → number of bits.  <br /></td></tr>
<tr class="separator:a21e08dec927792701cb73c6e6a1df927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436b24e6696f952a3d1a96ecf7191f96" id="r_a436b24e6696f952a3d1a96ecf7191f96"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a436b24e6696f952a3d1a96ecf7191f96">py_bv_item</a> (PyObject *self, Py_ssize_t i)</td></tr>
<tr class="memdesc:a436b24e6696f952a3d1a96ecf7191f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__getitem__, returns the bit at position i.  <br /></td></tr>
<tr class="separator:a436b24e6696f952a3d1a96ecf7191f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511eab9e240d4537ea455c8181ecbb48" id="r_a511eab9e240d4537ea455c8181ecbb48"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a511eab9e240d4537ea455c8181ecbb48">py_bv_slice</a> (PyObject *self, size_t start, size_t stop, size_t step, size_t slicelength)</td></tr>
<tr class="memdesc:a511eab9e240d4537ea455c8181ecbb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements slicing for BitVector.__getitem__ with a slice object.  <br /></td></tr>
<tr class="separator:a511eab9e240d4537ea455c8181ecbb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9db01fecf7acf29d81e6af54c2b1a1" id="r_a1a9db01fecf7acf29d81e6af54c2b1a1"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a1a9db01fecf7acf29d81e6af54c2b1a1">py_bv_subscript</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:a1a9db01fecf7acf29d81e6af54c2b1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__getitem__ dispatch for index or slice.  <br /></td></tr>
<tr class="separator:a1a9db01fecf7acf29d81e6af54c2b1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4f14c0adf92741fd193d14fee2bd6e" id="r_a9a4f14c0adf92741fd193d14fee2bd6e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a9a4f14c0adf92741fd193d14fee2bd6e">py_bv_ass_item</a> (PyObject *self, Py_ssize_t i, PyObject *value)</td></tr>
<tr class="memdesc:a9a4f14c0adf92741fd193d14fee2bd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__setitem__ for a single index.  <br /></td></tr>
<tr class="separator:a9a4f14c0adf92741fd193d14fee2bd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fcf5d2628aa7a30dba01a1224492a6" id="r_ac5fcf5d2628aa7a30dba01a1224492a6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ac5fcf5d2628aa7a30dba01a1224492a6">py_bv_ass_slice</a> (PyObject *self, size_t start, size_t stop, size_t step, size_t slicelength, PyObject *value)</td></tr>
<tr class="memdesc:ac5fcf5d2628aa7a30dba01a1224492a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__setitem__ for slice assignment.  <br /></td></tr>
<tr class="separator:ac5fcf5d2628aa7a30dba01a1224492a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde6296db3ce5161082498d618fda1ea" id="r_adde6296db3ce5161082498d618fda1ea"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#adde6296db3ce5161082498d618fda1ea">py_bv_ass_subscript</a> (PyObject *self, PyObject *arg, PyObject *value)</td></tr>
<tr class="memdesc:adde6296db3ce5161082498d618fda1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements BitVector.__setitem__ dispatch for index or slice.  <br /></td></tr>
<tr class="separator:adde6296db3ce5161082498d618fda1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16b0c5b44b6cdd492918469bcbf7f96" id="r_ac16b0c5b44b6cdd492918469bcbf7f96"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ac16b0c5b44b6cdd492918469bcbf7f96">py_bv_contains</a> (PyObject *self, PyObject *value)</td></tr>
<tr class="memdesc:ac16b0c5b44b6cdd492918469bcbf7f96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>contains</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, other) → boolean.  <br /></td></tr>
<tr class="separator:ac16b0c5b44b6cdd492918469bcbf7f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881c976bd771094e5f63e77dbbacb95b" id="r_a881c976bd771094e5f63e77dbbacb95b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a881c976bd771094e5f63e77dbbacb95b">py_bviter_dealloc</a> (PyObject *self)</td></tr>
<tr class="memdesc:a881c976bd771094e5f63e77dbbacb95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate a <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> iterator object.  <br /></td></tr>
<tr class="separator:a881c976bd771094e5f63e77dbbacb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778fdf5cc237723a965b88bf6011f519" id="r_a778fdf5cc237723a965b88bf6011f519"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a778fdf5cc237723a965b88bf6011f519">py_bviter_iternext</a> (PyObject *self)</td></tr>
<tr class="memdesc:a778fdf5cc237723a965b88bf6011f519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next bit as a Python boolean.  <br /></td></tr>
<tr class="separator:a778fdf5cc237723a965b88bf6011f519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25220119ba92df39434d4868745481b1" id="r_a25220119ba92df39434d4868745481b1"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a25220119ba92df39434d4868745481b1">py_bv_iter</a> (PyObject *self)</td></tr>
<tr class="memdesc:a25220119ba92df39434d4868745481b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a new <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> iterator.  <br /></td></tr>
<tr class="separator:a25220119ba92df39434d4868745481b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bf92aec4a330bd6b0e0ad143f3ab36" id="r_a09bf92aec4a330bd6b0e0ad143f3ab36"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a09bf92aec4a330bd6b0e0ad143f3ab36">py_bv_and</a> (PyObject *oA, PyObject *oB)</td></tr>
<tr class="memdesc:a09bf92aec4a330bd6b0e0ad143f3ab36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>and</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a09bf92aec4a330bd6b0e0ad143f3ab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad100d02b61be2f9082ce249bc3099ddc" id="r_ad100d02b61be2f9082ce249bc3099ddc"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ad100d02b61be2f9082ce249bc3099ddc">py_bv_iand</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:ad100d02b61be2f9082ce249bc3099ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>iand</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) in-place AND.  <br /></td></tr>
<tr class="separator:ad100d02b61be2f9082ce249bc3099ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80404db499e4bc108a6ac98bf2a117e" id="r_ac80404db499e4bc108a6ac98bf2a117e"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ac80404db499e4bc108a6ac98bf2a117e">py_bv_or</a> (PyObject *oA, PyObject *oB)</td></tr>
<tr class="memdesc:ac80404db499e4bc108a6ac98bf2a117e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>or</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:ac80404db499e4bc108a6ac98bf2a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a23db722235b739cd8ca7af6aa096dd" id="r_a2a23db722235b739cd8ca7af6aa096dd"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a2a23db722235b739cd8ca7af6aa096dd">py_bv_ior</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:a2a23db722235b739cd8ca7af6aa096dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ior</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) in-place OR.  <br /></td></tr>
<tr class="separator:a2a23db722235b739cd8ca7af6aa096dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe0bb25553ffc47f530cf93cb46ca42" id="r_aefe0bb25553ffc47f530cf93cb46ca42"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#aefe0bb25553ffc47f530cf93cb46ca42">py_bv_xor</a> (PyObject *oA, PyObject *oB)</td></tr>
<tr class="memdesc:aefe0bb25553ffc47f530cf93cb46ca42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>xor</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:aefe0bb25553ffc47f530cf93cb46ca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239e981d1a323d9bce7c018f08b5f081" id="r_a239e981d1a323d9bce7c018f08b5f081"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a239e981d1a323d9bce7c018f08b5f081">py_bv_ixor</a> (PyObject *self, PyObject *arg)</td></tr>
<tr class="memdesc:a239e981d1a323d9bce7c018f08b5f081"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ixor</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) in-place XOR.  <br /></td></tr>
<tr class="separator:a239e981d1a323d9bce7c018f08b5f081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21759f5b861d2e61454568931070553d" id="r_a21759f5b861d2e61454568931070553d"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a21759f5b861d2e61454568931070553d">py_bv_invert</a> (PyObject *self)</td></tr>
<tr class="memdesc:a21759f5b861d2e61454568931070553d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>invert</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a21759f5b861d2e61454568931070553d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a48ec54bd2020b5f9c53ccb60efad9e" id="r_a2a48ec54bd2020b5f9c53ccb60efad9e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a2a48ec54bd2020b5f9c53ccb60efad9e">py_bv_bool</a> (PyObject *self)</td></tr>
<tr class="memdesc:a2a48ec54bd2020b5f9c53ccb60efad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>bool</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → boolean.  <br /></td></tr>
<tr class="separator:a2a48ec54bd2020b5f9c53ccb60efad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676b77aaaa3053d90f7ea7f95e22e8eb" id="r_a676b77aaaa3053d90f7ea7f95e22e8eb"><td class="memItemLeft" align="right" valign="top">static PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a676b77aaaa3053d90f7ea7f95e22e8eb">py_bv_get_size</a> (PyObject *self, void *closure)</td></tr>
<tr class="memdesc:a676b77aaaa3053d90f7ea7f95e22e8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the read-only "bits" property.  <br /></td></tr>
<tr class="separator:a676b77aaaa3053d90f7ea7f95e22e8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470ee7402be5662a9f0651631ec1f172" id="r_a470ee7402be5662a9f0651631ec1f172"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a470ee7402be5662a9f0651631ec1f172">py_bv_set_size</a> (PyObject *self, void *closure)</td></tr>
<tr class="memdesc:a470ee7402be5662a9f0651631ec1f172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the read-only "bits" property, always raises.  <br /></td></tr>
<tr class="separator:a470ee7402be5662a9f0651631ec1f172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821b81ab1b3cde6c5e96b908b1e9c62f" id="r_a821b81ab1b3cde6c5e96b908b1e9c62f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a821b81ab1b3cde6c5e96b908b1e9c62f">PyDoc_STRVAR</a> (BitVector__doc__, &quot;BitVector(size: int)\n&quot; &quot;\n&quot; &quot;A high-performance, fixed-size 1D bit array.\n\n&quot; &quot;Supports random access, slicing, bitwise ops, and fast iteration.\n\n&quot; &quot;Parameters\n&quot; &quot;----------\n&quot; &quot;size : int\n&quot; &quot;    Number of bits in the vector.\n\n&quot; &quot;Attributes\n&quot; &quot;----------\n&quot; &quot;bits : int\n&quot; &quot;    The length of this BitVector.\n&quot;)</td></tr>
<tr class="separator:a821b81ab1b3cde6c5e96b908b1e9c62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f427b0cfdb1957c3605e10019f007bd" id="r_a8f427b0cfdb1957c3605e10019f007bd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a8f427b0cfdb1957c3605e10019f007bd">cbits_module_exec</a> (PyObject *module)</td></tr>
<tr class="memdesc:a8f427b0cfdb1957c3605e10019f007bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module exec callback: register <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> type and metadata.  <br /></td></tr>
<tr class="separator:a8f427b0cfdb1957c3605e10019f007bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a66f6dc0f1f2e3f2080e50d639e37d2" id="r_a5a66f6dc0f1f2e3f2080e50d639e37d2"><td class="memItemLeft" align="right" valign="top">PyMODINIT_FUNC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a5a66f6dc0f1f2e3f2080e50d639e37d2">PyInit__cbits</a> (void)</td></tr>
<tr class="memdesc:a5a66f6dc0f1f2e3f2080e50d639e37d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python entrypoint for _cbits extension module.  <br /></td></tr>
<tr class="separator:a5a66f6dc0f1f2e3f2080e50d639e37d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5625b28f722b33c1597cff28478aeb9a" id="r_a5625b28f722b33c1597cff28478aeb9a"><td class="memItemLeft" align="right" valign="top">PyTypeObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a5625b28f722b33c1597cff28478aeb9a">PyBitVectorPtr</a> = NULL</td></tr>
<tr class="separator:a5625b28f722b33c1597cff28478aeb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc423083838b34b1ff8c04a410a35e3" id="r_a5bc423083838b34b1ff8c04a410a35e3"><td class="memItemLeft" align="right" valign="top">static PyMethodDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a5bc423083838b34b1ff8c04a410a35e3">BitVector_methods</a> []</td></tr>
<tr class="memdesc:a5bc423083838b34b1ff8c04a410a35e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method table for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> core methods.  <br /></td></tr>
<tr class="separator:a5bc423083838b34b1ff8c04a410a35e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5741aa05e43e6ec2d650341f5d4b1a0b" id="r_a5741aa05e43e6ec2d650341f5d4b1a0b"><td class="memItemLeft" align="right" valign="top">static PyType_Slot&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a5741aa05e43e6ec2d650341f5d4b1a0b">PyBitVectorIter_slots</a> []</td></tr>
<tr class="memdesc:a5741aa05e43e6ec2d650341f5d4b1a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slots for the _BitVectorIter type.  <br /></td></tr>
<tr class="separator:a5741aa05e43e6ec2d650341f5d4b1a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8cff07e2be78e6f372eab2796c7e66" id="r_a7f8cff07e2be78e6f372eab2796c7e66"><td class="memItemLeft" align="right" valign="top">static PyType_Spec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a7f8cff07e2be78e6f372eab2796c7e66">PyBitVectorIter_spec</a></td></tr>
<tr class="memdesc:a7f8cff07e2be78e6f372eab2796c7e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type specification for cbits._BitVectorIter.  <br /></td></tr>
<tr class="separator:a7f8cff07e2be78e6f372eab2796c7e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e8f8f4e20d3e7dec4041e7a9b47c1f" id="r_ad5e8f8f4e20d3e7dec4041e7a9b47c1f"><td class="memItemLeft" align="right" valign="top">static PyTypeObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#ad5e8f8f4e20d3e7dec4041e7a9b47c1f">PyBitVectorIterType</a> = NULL</td></tr>
<tr class="separator:ad5e8f8f4e20d3e7dec4041e7a9b47c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9d2206089523b6bc6fbac996e9895e" id="r_aed9d2206089523b6bc6fbac996e9895e"><td class="memItemLeft" align="right" valign="top">static PyGetSetDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#aed9d2206089523b6bc6fbac996e9895e">PyBitVector_getset</a> []</td></tr>
<tr class="memdesc:aed9d2206089523b6bc6fbac996e9895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Property definitions for the <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> type.  <br /></td></tr>
<tr class="separator:aed9d2206089523b6bc6fbac996e9895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c88cffd30f4952e8257b1cbe6571b27" id="r_a3c88cffd30f4952e8257b1cbe6571b27"><td class="memItemLeft" align="right" valign="top">static PyType_Slot&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a3c88cffd30f4952e8257b1cbe6571b27">PyBitVector_slots</a> []</td></tr>
<tr class="memdesc:a3c88cffd30f4952e8257b1cbe6571b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot table for the <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> type.  <br /></td></tr>
<tr class="separator:a3c88cffd30f4952e8257b1cbe6571b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cbcf7245043dda2766117451034a6c" id="r_a85cbcf7245043dda2766117451034a6c"><td class="memItemLeft" align="right" valign="top">PyType_Spec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a85cbcf7245043dda2766117451034a6c">PyBitVector_spec</a></td></tr>
<tr class="memdesc:a85cbcf7245043dda2766117451034a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type specification for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>.  <br /></td></tr>
<tr class="separator:a85cbcf7245043dda2766117451034a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843c32fa48b7e83c731f95efec9e8b3f" id="r_a843c32fa48b7e83c731f95efec9e8b3f"><td class="memItemLeft" align="right" valign="top">static PyModuleDef_Slot&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#a843c32fa48b7e83c731f95efec9e8b3f">cbits_module_slots</a> []</td></tr>
<tr class="memdesc:a843c32fa48b7e83c731f95efec9e8b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module initialization slots.  <br /></td></tr>
<tr class="separator:a843c32fa48b7e83c731f95efec9e8b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf11ef2595c77d036c93c64deed19ce2" id="r_aaf11ef2595c77d036c93c64deed19ce2"><td class="memItemLeft" align="right" valign="top">static PyModuleDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="binding_8c.html#aaf11ef2595c77d036c93c64deed19ce2">cbits_module</a></td></tr>
<tr class="memdesc:aaf11ef2595c77d036c93c64deed19ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the _cbits extension module.  <br /></td></tr>
<tr class="separator:aaf11ef2595c77d036c93c64deed19ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Python C-API bindings for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<p>Defines the Python-level <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> type wrapping the C <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> API, including:</p><ul>
<li><a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> type and lifecycle (tp_new, tp_init, tp_dealloc)</li>
<li>Core <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> methods (get, set, clear, flip, rank, copy)</li>
<li>Sequence, numeric and richcompare protocols</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bitvector_8h.html" title="Packed BitVector C-API declarations.">include/bitvector.h</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>lambdaphoenix </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.0 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2025 lambdaphoenix </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7b13fba70d68d647dc3c308c0be92240" name="a7b13fba70d68d647dc3c308c0be92240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b13fba70d68d647dc3c308c0be92240">&#9670;&#160;</a></span>ADD_OBJECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADD_OBJECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">module, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">object&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        (PyModule_AddObject(module, name, <span class="keywordtype">object</span>) == 0 \</div>
<div class="line">             ? (Py_XINCREF(<span class="keywordtype">object</span>), 0)                 \</div>
<div class="line">             : -1)</div>
</div><!-- fragment -->
<p>Add a PyObject to a module, handling reference counts portably. </p>
<p>On Python ≥ 3.12, PyModule_AddObjectRef() is available and automatically steals a reference. On older versions, we fall back to PyModule_AddObject() and manually increment the reference on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>The Python module to which the object is added. </td></tr>
    <tr><td class="paramname">name</td><td>The attribute name under which the object is registered. </td></tr>
    <tr><td class="paramname">object</td><td>The PyObject pointer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure (exception set by PyModule_AddObject*). </dd></dl>

</div>
</div>
<a id="a3a1146a73d52acb0776f13d2d43954d0" name="a3a1146a73d52acb0776f13d2d43954d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1146a73d52acb0776f13d2d43954d0">&#9670;&#160;</a></span>CHECK_BV_BOTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_BV_BOTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!PyObject_TypeCheck(a, <a class="code hl_variable" href="binding_8c.html#a5625b28f722b33c1597cff28478aeb9a">PyBitVectorPtr</a>) || \</div>
<div class="line">        !PyObject_TypeCheck(b, <a class="code hl_variable" href="binding_8c.html#a5625b28f722b33c1597cff28478aeb9a">PyBitVectorPtr</a>)) { \</div>
<div class="line">        Py_RETURN_NOTIMPLEMENTED;                 \</div>
<div class="line">    }</div>
<div class="ttc" id="abinding_8c_html_a5625b28f722b33c1597cff28478aeb9a"><div class="ttname"><a href="binding_8c.html#a5625b28f722b33c1597cff28478aeb9a">PyBitVectorPtr</a></div><div class="ttdeci">PyTypeObject * PyBitVectorPtr</div><div class="ttdef"><b>Definition</b> binding.c:54</div></div>
</div><!-- fragment -->
<p>Verify both <em>a</em> and <em>b</em> are <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a>, else return <code>NotImplemented</code>. </p>

</div>
</div>
<a id="a1db76aaaed3680d17b24435989491b21" name="a1db76aaaed3680d17b24435989491b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db76aaaed3680d17b24435989491b21">&#9670;&#160;</a></span>CHECK_BV_OBJ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_BV_OBJ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!PyObject_TypeCheck(o, <a class="code hl_variable" href="binding_8c.html#a5625b28f722b33c1597cff28478aeb9a">PyBitVectorPtr</a>)) {               \</div>
<div class="line">        PyErr_SetString(PyExc_TypeError, <span class="stringliteral">&quot;Expected BitVector&quot;</span>); \</div>
<div class="line">        <span class="keywordflow">return</span> NULL;                                            \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Verify that <em>o</em> is a <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance or raise <code>TypeError</code>. </p>

</div>
</div>
<a id="ac9efdaac9411d0868b715edccca3269d" name="ac9efdaac9411d0868b715edccca3269d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9efdaac9411d0868b715edccca3269d">&#9670;&#160;</a></span>PY_SSIZE_T_CLEAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PY_SSIZE_T_CLEAN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a66f1d18ed7869c72e4d5e383af06f48f" name="a66f1d18ed7869c72e4d5e383af06f48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f1d18ed7869c72e4d5e383af06f48f">&#9670;&#160;</a></span>bv_parse_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int bv_parse_index </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse and validate a single index argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Python argument. </td></tr>
    <tr><td class="paramname">p_index</td><td>Output pointer to store the validated index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (p_index set), -1 on failure (exception set). </dd></dl>

</div>
</div>
<a id="af83d6c14dbf421173b34f8b69d00da95" name="af83d6c14dbf421173b34f8b69d00da95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83d6c14dbf421173b34f8b69d00da95">&#9670;&#160;</a></span>bv_parse_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int bv_parse_tuple </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse and validate a (start, length) range tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">args</td><td>Python argument tuple (start, length). </td></tr>
    <tr><td class="paramname">p_start</td><td>Output pointer for start index. </td></tr>
    <tr><td class="paramname">p_len</td><td>Output pointer for length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (outputs set), -1 on failure (exception set). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.2.0 </dd></dl>

</div>
</div>
<a id="a5e6fffc9d5f721ba9836bdc7c173499a" name="a5e6fffc9d5f721ba9836bdc7c173499a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6fffc9d5f721ba9836bdc7c173499a">&#9670;&#160;</a></span>bv_wrap_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * bv_wrap_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBitVector.html">BitVector</a> *&#160;</td>
          <td class="paramname"><em>bv_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap a native <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> in a new <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> Python object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bv_data</td><td>Pointer to an allocated <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New reference to a <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a>, or NULL on allocation failure. </dd></dl>

</div>
</div>
<a id="a8f427b0cfdb1957c3605e10019f007bd" name="a8f427b0cfdb1957c3605e10019f007bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f427b0cfdb1957c3605e10019f007bd">&#9670;&#160;</a></span>cbits_module_exec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cbits_module_exec </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Module exec callback: register <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> type and metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>New module instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 on failure (exception set). </dd></dl>

</div>
</div>
<a id="a09bf92aec4a330bd6b0e0ad143f3ab36" name="a09bf92aec4a330bd6b0e0ad143f3ab36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bf92aec4a330bd6b0e0ad143f3ab36">&#9670;&#160;</a></span>py_bv_and()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_and </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>oA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>oB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>and</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left operand. </td></tr>
    <tr><td class="paramname">b</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> representing bitwise AND; NULL on error. </dd></dl>

</div>
</div>
<a id="a9a4f14c0adf92741fd193d14fee2bd6e" name="a9a4f14c0adf92741fd193d14fee2bd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4f14c0adf92741fd193d14fee2bd6e">&#9670;&#160;</a></span>py_bv_ass_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bv_ass_item </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Py_ssize_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements BitVector.__setitem__ for a single index. </p>
<p>Sets or clears the bit at position i based on the truth value of <code>value</code>. Raises IndexError if the index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">i</td><td>Index of the bit to assign. </td></tr>
    <tr><td class="paramname">value</td><td>Python object interpreted as boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 on error (with exception set). </dd></dl>

</div>
</div>
<a id="ac5fcf5d2628aa7a30dba01a1224492a6" name="ac5fcf5d2628aa7a30dba01a1224492a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fcf5d2628aa7a30dba01a1224492a6">&#9670;&#160;</a></span>py_bv_ass_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bv_ass_slice </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slicelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements BitVector.__setitem__ for slice assignment. </p>
<p>Assigns bits from an iterable <code>value</code> to the slice [start:stop:step]. Raises IndexError or ValueError on length mismatch or out-of-range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">start</td><td>Start index of the slice. </td></tr>
    <tr><td class="paramname">stop</td><td>End index (exclusive) of the slice. </td></tr>
    <tr><td class="paramname">step</td><td>Step size for the slice. </td></tr>
    <tr><td class="paramname">slicelength</td><td>Number of elements in the resulting slice. </td></tr>
    <tr><td class="paramname">value</td><td>Iterable of boolean-convertible Python objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 on error (with exception set). </dd></dl>

</div>
</div>
<a id="adde6296db3ce5161082498d618fda1ea" name="adde6296db3ce5161082498d618fda1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde6296db3ce5161082498d618fda1ea">&#9670;&#160;</a></span>py_bv_ass_subscript()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bv_ass_subscript </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements BitVector.__setitem__ dispatch for index or slice. </p>
<p>Delegates to py_bv_ass_item or py_bv_ass_slice depending on type of <code>arg</code>. Does not support item deletion (value==NULL).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Index or slice object. </td></tr>
    <tr><td class="paramname">value</td><td>Python object to assign (must not be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 on error (with exception set). </dd></dl>

</div>
</div>
<a id="a2a48ec54bd2020b5f9c53ccb60efad9e" name="a2a48ec54bd2020b5f9c53ccb60efad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a48ec54bd2020b5f9c53ccb60efad9e">&#9670;&#160;</a></span>py_bv_bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bv_bool </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>bool</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if any bit is set, 0 otherwise </dd></dl>

</div>
</div>
<a id="af3d93df3d5ac6faaa1366b7f31402798" name="af3d93df3d5ac6faaa1366b7f31402798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d93df3d5ac6faaa1366b7f31402798">&#9670;&#160;</a></span>py_bv_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_clear </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.clear(index). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">args</td><td>Python argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None on success, NULL on error. </dd></dl>

</div>
</div>
<a id="ac489bee1773936cb5e811e2d0252707f" name="ac489bee1773936cb5e811e2d0252707f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac489bee1773936cb5e811e2d0252707f">&#9670;&#160;</a></span>py_bv_clear_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_clear_range </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.clear_range(start, length). </p>
<p>Calls <a class="el" href="bitvector_8h.html#a7e326b3e801d3ae2c8372fd66a493b21" title="Clear all bits in the half‑open range [start, start+len).">bv_clear_range()</a> to clear all bits in the half‑open range [start, start+length). Marks the hash cache invalid and returns None.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">args</td><td>Tuple (start, length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Py_None on success, NULL on error (with exception set). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.2.0 </dd></dl>

</div>
</div>
<a id="ac16b0c5b44b6cdd492918469bcbf7f96" name="ac16b0c5b44b6cdd492918469bcbf7f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16b0c5b44b6cdd492918469bcbf7f96">&#9670;&#160;</a></span>py_bv_contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bv_contains </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>contains</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, other) → boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. (haystack). </td></tr>
    <tr><td class="paramname">value</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance (needle). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if contained, 0 otherwise </dd></dl>

</div>
</div>
<a id="a67c5804ed6745718be7527a3aae4664a" name="a67c5804ed6745718be7527a3aae4664a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c5804ed6745718be7527a3aae4664a">&#9670;&#160;</a></span>py_bv_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_copy </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>ignored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.copy() → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">UNUSED</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> copy </dd></dl>

</div>
</div>
<a id="ad5569e465c62a44515af6f4aa324fc60" name="ad5569e465c62a44515af6f4aa324fc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5569e465c62a44515af6f4aa324fc60">&#9670;&#160;</a></span>py_bv_deepcopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_deepcopy </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>memo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.__deepcopy__(memo) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">memo</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> copy </dd></dl>

</div>
</div>
<a id="a38c1503708121705e22921b48fabf14c" name="a38c1503708121705e22921b48fabf14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c1503708121705e22921b48fabf14c">&#9670;&#160;</a></span>py_bv_flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_flip </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.flip(index). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Python argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None on success, NULL on error. </dd></dl>

</div>
</div>
<a id="abaa5a8a1af4ebbd29f13a650c21f3af2" name="abaa5a8a1af4ebbd29f13a650c21f3af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa5a8a1af4ebbd29f13a650c21f3af2">&#9670;&#160;</a></span>py_bv_flip_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_flip_range </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.flip_range(start, length). </p>
<p>Calls <a class="el" href="bitvector_8h.html#a2e3fbc3abe02f0db7577453638cb46b7" title="Toggle (flip) all bits in the half‑open range [start, start+len).">bv_flip_range()</a> to toggle all bits in the half‑open range [start, start+length). Marks the hash cache invalid and returns None.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">args</td><td>Tuple (start, length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Py_None on success, NULL on error (with exception set). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.2.0 </dd></dl>

</div>
</div>
<a id="a2d55c861d7fdf3b0e9b95497fdb6a6e4" name="a2d55c861d7fdf3b0e9b95497fdb6a6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d55c861d7fdf3b0e9b95497fdb6a6e4">&#9670;&#160;</a></span>py_bv_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void py_bv_free </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate a <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f4a245c9973679b1f9af1379e81821" name="a95f4a245c9973679b1f9af1379e81821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f4a245c9973679b1f9af1379e81821">&#9670;&#160;</a></span>py_bv_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_get </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.get(index) → bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Python argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is bit is set, false otherwise </dd></dl>

</div>
</div>
<a id="a676b77aaaa3053d90f7ea7f95e22e8eb" name="a676b77aaaa3053d90f7ea7f95e22e8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676b77aaaa3053d90f7ea7f95e22e8eb">&#9670;&#160;</a></span>py_bv_get_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_get_size </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the read-only "bits" property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">closure</td><td>Unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Python integer of the bit-length </dd></dl>

</div>
</div>
<a id="a2f67615df466f74b6f90c13dc37589ff" name="a2f67615df466f74b6f90c13dc37589ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f67615df466f74b6f90c13dc37589ff">&#9670;&#160;</a></span>py_bv_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Py_hash_t py_bv_hash </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>hash</b> for a <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> object. </p>
<p>Computes a hash over the vector’s packed bit data using Python’s internal _Py_HashBytes helper. The result is cached in the object until the <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> is mutated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Py_hash_t value derived from the bit‐pattern contents. </dd></dl>

</div>
</div>
<a id="ad100d02b61be2f9082ce249bc3099ddc" name="ad100d02b61be2f9082ce249bc3099ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad100d02b61be2f9082ce249bc3099ddc">&#9670;&#160;</a></span>py_bv_iand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_iand </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>iand</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) in-place AND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left operand (modified in place). </td></tr>
    <tr><td class="paramname">b</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self on success, NULL on error. </dd></dl>

</div>
</div>
<a id="a510d7b30401e3d3bd188a9a7de61803d" name="a510d7b30401e3d3bd188a9a7de61803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510d7b30401e3d3bd188a9a7de61803d">&#9670;&#160;</a></span>py_bv_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bv_init </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>init</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector(size)</a>: allocate the underlying C <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">args</td><td>Positional args tuple. </td></tr>
    <tr><td class="paramname">kwds</td><td>Keyword args dict. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (with exception set). </dd></dl>

</div>
</div>
<a id="a21759f5b861d2e61454568931070553d" name="a21759f5b861d2e61454568931070553d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21759f5b861d2e61454568931070553d">&#9670;&#160;</a></span>py_bv_invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_invert </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>invert</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> instance with all bits toggled, NULL on error; </dd></dl>

</div>
</div>
<a id="a2a23db722235b739cd8ca7af6aa096dd" name="a2a23db722235b739cd8ca7af6aa096dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a23db722235b739cd8ca7af6aa096dd">&#9670;&#160;</a></span>py_bv_ior()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_ior </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>ior</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) in-place OR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left operand (modified in place). </td></tr>
    <tr><td class="paramname">b</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self on success, NULL on error. </dd></dl>

</div>
</div>
<a id="a436b24e6696f952a3d1a96ecf7191f96" name="a436b24e6696f952a3d1a96ecf7191f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436b24e6696f952a3d1a96ecf7191f96">&#9670;&#160;</a></span>py_bv_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_item </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Py_ssize_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements BitVector.__getitem__, returns the bit at position i. </p>
<p>This function checks bounds and returns the corresponding Python boolean (True/False). On out-of-range access it raises IndexError.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">i</td><td>Index to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New reference to Py_True or Py_False on success; NULL and IndexError on failure. </dd></dl>

</div>
</div>
<a id="a25220119ba92df39434d4868745481b1" name="a25220119ba92df39434d4868745481b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25220119ba92df39434d4868745481b1">&#9670;&#160;</a></span>py_bv_iter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_iter </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a new <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> iterator. </p>
<p>Implements the tp_iter slot. Allocates a fresh <a class="el" href="structPyBitVectorIter.html" title="Iterator structure for PyBitVector.">PyBitVectorIter</a>, initializes its state, and returns it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New iterator object or NULL on allocation failure. </dd></dl>

</div>
</div>
<a id="a239e981d1a323d9bce7c018f08b5f081" name="a239e981d1a323d9bce7c018f08b5f081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239e981d1a323d9bce7c018f08b5f081">&#9670;&#160;</a></span>py_bv_ixor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_ixor </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>ixor</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) in-place XOR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left operand (modified in place). </td></tr>
    <tr><td class="paramname">b</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Self on success, NULL on error. </dd></dl>

</div>
</div>
<a id="a21e08dec927792701cb73c6e6a1df927" name="a21e08dec927792701cb73c6e6a1df927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e08dec927792701cb73c6e6a1df927">&#9670;&#160;</a></span>py_bv_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Py_ssize_t py_bv_len </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>len</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → number of bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits as Py_ssize_t. </dd></dl>

</div>
</div>
<a id="a33699ee8e583f6b69da8d7a4b011de12" name="a33699ee8e583f6b69da8d7a4b011de12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33699ee8e583f6b69da8d7a4b011de12">&#9670;&#160;</a></span>py_bv_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_new </td>
          <td>(</td>
          <td class="paramtype">PyTypeObject *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>new</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>: allocate the Python object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The Python type object. </td></tr>
    <tr><td class="paramname">args</td><td>Positional args (unused). </td></tr>
    <tr><td class="paramname">kwds</td><td>Keyword args (unused). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New, uninitialized <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> or NULL on failure. </dd></dl>

</div>
</div>
<a id="ac80404db499e4bc108a6ac98bf2a117e" name="ac80404db499e4bc108a6ac98bf2a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80404db499e4bc108a6ac98bf2a117e">&#9670;&#160;</a></span>py_bv_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_or </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>oA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>oB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>or</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left operand. </td></tr>
    <tr><td class="paramname">b</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> representing bitwise OR; NULL on error. </dd></dl>

</div>
</div>
<a id="a6596d7e4e07e24155651258c9091028b" name="a6596d7e4e07e24155651258c9091028b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6596d7e4e07e24155651258c9091028b">&#9670;&#160;</a></span>py_bv_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_rank </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.rank(index) → bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">args</td><td>Array of Python arguments. </td></tr>
    <tr><td class="paramname">n_args</td><td>Number of arguments expected (should be 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bits set in range [0...pos] </dd></dl>

</div>
</div>
<a id="a7c29dda376c942eaafd3e1297c392b6c" name="a7c29dda376c942eaafd3e1297c392b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c29dda376c942eaafd3e1297c392b6c">&#9670;&#160;</a></span>py_bv_repr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_repr </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>repr</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New Python string describing the object. </dd></dl>

</div>
</div>
<a id="a907d626799062d832d366b69aa7755ef" name="a907d626799062d832d366b69aa7755ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907d626799062d832d366b69aa7755ef">&#9670;&#160;</a></span>py_bv_richcompare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_richcompare </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rich comparison (== and !=) for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First operant. </td></tr>
    <tr><td class="paramname">b</td><td>Second operant. </td></tr>
    <tr><td class="paramname">op</td><td>Comparison operation (Py_EQ or Py_NE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Py_True or Py_False on success; Py_RETURN_NOTIMPLEMENTED if unsupported. </dd></dl>

</div>
</div>
<a id="a83289c5959b0cbc9ef594a00054b3d0a" name="a83289c5959b0cbc9ef594a00054b3d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83289c5959b0cbc9ef594a00054b3d0a">&#9670;&#160;</a></span>py_bv_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_set </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.set(index). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Python argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None on success, NULL on error. </dd></dl>

</div>
</div>
<a id="a5a36766609fe6f9a6f7b436d305d29cd" name="a5a36766609fe6f9a6f7b436d305d29cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a36766609fe6f9a6f7b436d305d29cd">&#9670;&#160;</a></span>py_bv_set_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_set_range </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Python binding for BitVector.set_range(start, length). </p>
<p>Calls <a class="el" href="bitvector_8h.html#a182f282c1a69c41d230ead44c24eec77" title="Set all bits in the half‑open range [start, start+len).">bv_set_range()</a> to set all bits in the half‑open range [start, start+length). Marks the hash cache invalid and returns None.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">args</td><td>Tuple (start, length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Py_None on success, NULL on error (with exception set). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.2.0 </dd></dl>

</div>
</div>
<a id="a470ee7402be5662a9f0651631ec1f172" name="a470ee7402be5662a9f0651631ec1f172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470ee7402be5662a9f0651631ec1f172">&#9670;&#160;</a></span>py_bv_set_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int py_bv_set_size </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter for the read-only "bits" property, always raises. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">closure</td><td>Unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 and sets AttributeError </dd></dl>

</div>
</div>
<a id="a511eab9e240d4537ea455c8181ecbb48" name="a511eab9e240d4537ea455c8181ecbb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511eab9e240d4537ea455c8181ecbb48">&#9670;&#160;</a></span>py_bv_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_slice </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>slicelength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements slicing for BitVector.__getitem__ with a slice object. </p>
<p>Creates and returns a new <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> containing elements from [start:stop:step]. Raises IndexError if any index is out of bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">start</td><td>Start index of the slice. </td></tr>
    <tr><td class="paramname">stop</td><td>End index (exclusive) of the slice. </td></tr>
    <tr><td class="paramname">step</td><td>Step size for the slice. </td></tr>
    <tr><td class="paramname">slicelength</td><td>Number of elements in the resulting slice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> wrapping the sliced <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>; NULL and IndexError on failure. </dd></dl>

</div>
</div>
<a id="a08bbcefc5bea6072787075f0a7e305c8" name="a08bbcefc5bea6072787075f0a7e305c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bbcefc5bea6072787075f0a7e305c8">&#9670;&#160;</a></span>py_bv_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_str </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>str</b> for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New Python string "BitVector with X bits". </dd></dl>

</div>
</div>
<a id="a1a9db01fecf7acf29d81e6af54c2b1a1" name="a1a9db01fecf7acf29d81e6af54c2b1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9db01fecf7acf29d81e6af54c2b1a1">&#9670;&#160;</a></span>py_bv_subscript()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_subscript </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements BitVector.__getitem__ dispatch for index or slice. </p>
<p>Delegates either to py_bv_item (for integer indices) or to py_bv_slice (for slice objects). Raises TypeError for unsupported types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A Python <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> instance. </td></tr>
    <tr><td class="paramname">arg</td><td>Index or slice object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New reference to a Python bool or <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a>; NULL and exception on error. </dd></dl>

</div>
</div>
<a id="aefe0bb25553ffc47f530cf93cb46ca42" name="aefe0bb25553ffc47f530cf93cb46ca42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe0bb25553ffc47f530cf93cb46ca42">&#9670;&#160;</a></span>py_bv_xor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bv_xor </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>oA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>oB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>xor</b>(<a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>, <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>) → <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left operand. </td></tr>
    <tr><td class="paramname">b</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> representing bitwise XOR; NULL on error. </dd></dl>

</div>
</div>
<a id="a881c976bd771094e5f63e77dbbacb95b" name="a881c976bd771094e5f63e77dbbacb95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881c976bd771094e5f63e77dbbacb95b">&#9670;&#160;</a></span>py_bviter_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void py_bviter_dealloc </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate a <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> iterator object. </p>
<p>Releases the reference to the parent <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> and frees the iterator struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A <a class="el" href="structPyBitVectorIter.html" title="Iterator structure for PyBitVector.">PyBitVectorIter</a> instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a778fdf5cc237723a965b88bf6011f519" name="a778fdf5cc237723a965b88bf6011f519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778fdf5cc237723a965b88bf6011f519">&#9670;&#160;</a></span>py_bviter_iternext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static PyObject * py_bviter_iternext </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next bit as a Python boolean. </p>
<p>Reads one bit from the internal buffer and shifts it out. If all bits have been yielded, raises StopIteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A <a class="el" href="structPyBitVectorIter.html" title="Iterator structure for PyBitVector.">PyBitVectorIter</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Py_True or Py_False on success; NULL with StopIteration set at end-of-iteration. </dd></dl>

</div>
</div>
<a id="a821b81ab1b3cde6c5e96b908b1e9c62f" name="a821b81ab1b3cde6c5e96b908b1e9c62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821b81ab1b3cde6c5e96b908b1e9c62f">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">BitVector__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;BitVector(size: int)\n&quot; &quot;\n&quot; &quot;A high-&#160;</td>
          <td class="paramname"><em>performance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fixed-size 1D bit array.\n\n&quot; &quot;Supports random&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slicing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitwise&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">and fast iteration.\n\n&quot; &quot;Parameters\n&quot; &quot;----------\n&quot; &quot;size :int\n&quot; &quot; Number of bits in the vector.\n\n&quot; &quot;Attributes\n&quot; &quot;----------\n&quot; &quot;bits :int\n&quot; &quot; The length of this BitVector.\n&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68fec1a34b42e4faa10468e1b05d5a2a" name="a68fec1a34b42e4faa10468e1b05d5a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fec1a34b42e4faa10468e1b05d5a2a">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_clear__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;clear(index: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Clear the bit (set to False) at position *index*. Supports &quot; &quot;negative indexing.\n&quot; &quot;Raises IndexError if out of range.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab955783023262da680c8bcb054ba1963" name="ab955783023262da680c8bcb054ba1963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab955783023262da680c8bcb054ba1963">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_clear_range__doc__&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c3c7189ce65be48e710bd5fa5a03f87" name="a1c3c7189ce65be48e710bd5fa5a03f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3c7189ce65be48e710bd5fa5a03f87">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_copy__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;copy() -&gt; BitVector\n&quot; &quot;\n&quot; &quot;Return a copy of this BitVector.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadde30ba5221d4e50c79f97e995ee9cd" name="aadde30ba5221d4e50c79f97e995ee9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadde30ba5221d4e50c79f97e995ee9cd">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_copy_inline__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;__copy__() -&gt; BitVector\n&quot; &quot;\n&quot; &quot;Return a copy of this BitVector.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb4f67838cd25681435f80de1ac59357" name="aeb4f67838cd25681435f80de1ac59357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4f67838cd25681435f80de1ac59357">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_deepcopy__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;__deepcopy__(memo: dict) -&gt; BitVector\n&quot; &quot;\n&quot; &quot;Return a copy of this&#160;</td>
          <td class="paramname"><em>BitVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">registering it in *memo *.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeeb4bf04b7dba5886d67076d40167328" name="aeeb4bf04b7dba5886d67076d40167328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb4bf04b7dba5886d67076d40167328">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_flip__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;flip(index: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Toggle the bit at position *index*. Supports negative indexing.\n&quot; &quot;Raises IndexError if out of range.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae43697e8ed705eb2f0b49517a3c533aa" name="ae43697e8ed705eb2f0b49517a3c533aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43697e8ed705eb2f0b49517a3c533aa">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_flip_range__doc__&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f4f1973576a28570505fd8ebe44de7f" name="a4f4f1973576a28570505fd8ebe44de7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4f1973576a28570505fd8ebe44de7f">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_get__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;get(index: int) -&gt; bool\n&quot; &quot;\n&quot; &quot;Return the boolean value of the bit at position *index*.\n&quot; &quot;Negative indices are supported. Raises IndexError if out of range.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affc62d1304007fadd932f46d3952167e" name="affc62d1304007fadd932f46d3952167e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc62d1304007fadd932f46d3952167e">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_rank__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;rank(index: int) -&gt; int\n&quot; &quot;\n&quot; &quot;Count the number of bits set to True in the half-open range .\n&quot; &quot;Supports negative indexing. Raises IndexError if out of range.&quot;&#160;</td>
          <td class="paramname">[0..index]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a051fef147d43e118d591720c1ade81a7" name="a051fef147d43e118d591720c1ade81a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051fef147d43e118d591720c1ade81a7">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_set__doc__&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;set(index: int) -&gt; None\n&quot; &quot;\n&quot; &quot;Set the bit at position *index* to True. Supports negative indexing.\n&quot; &quot;Raises IndexError if out of range.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0168cda7bd3f2cbff1aa141999f47c7f" name="a0168cda7bd3f2cbff1aa141999f47c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0168cda7bd3f2cbff1aa141999f47c7f">&#9670;&#160;</a></span>PyDoc_STRVAR() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">py_bv_set_range__doc__&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a66f6dc0f1f2e3f2080e50d639e37d2" name="a5a66f6dc0f1f2e3f2080e50d639e37d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a66f6dc0f1f2e3f2080e50d639e37d2">&#9670;&#160;</a></span>PyInit__cbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyMODINIT_FUNC PyInit__cbits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python entrypoint for _cbits extension module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">void</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New module object (borrowed reference). </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5bc423083838b34b1ff8c04a410a35e3" name="a5bc423083838b34b1ff8c04a410a35e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc423083838b34b1ff8c04a410a35e3">&#9670;&#160;</a></span>BitVector_methods</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyMethodDef BitVector_methods[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;get&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#a95f4a245c9973679b1f9af1379e81821">py_bv_get</a>, METH_O, py_bv_get__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;set&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#a83289c5959b0cbc9ef594a00054b3d0a">py_bv_set</a>, METH_O, py_bv_set__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;clear&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#af3d93df3d5ac6faaa1366b7f31402798">py_bv_clear</a>, METH_O, py_bv_clear__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;flip&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#a38c1503708121705e22921b48fabf14c">py_bv_flip</a>, METH_O, py_bv_flip__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;set_range&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#a5a36766609fe6f9a6f7b436d305d29cd">py_bv_set_range</a>, METH_VARARGS,</div>
<div class="line">     py_bv_set_range__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;clear_range&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#ac489bee1773936cb5e811e2d0252707f">py_bv_clear_range</a>, METH_VARARGS,</div>
<div class="line">     py_bv_clear_range__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;flip_range&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#abaa5a8a1af4ebbd29f13a650c21f3af2">py_bv_flip_range</a>, METH_VARARGS,</div>
<div class="line">     py_bv_flip_range__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;rank&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#a6596d7e4e07e24155651258c9091028b">py_bv_rank</a>, METH_O, py_bv_rank__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;copy&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#a67c5804ed6745718be7527a3aae4664a">py_bv_copy</a>, METH_NOARGS, py_bv_copy__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;__copy__&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#a67c5804ed6745718be7527a3aae4664a">py_bv_copy</a>, METH_NOARGS,</div>
<div class="line">     py_bv_copy_inline__doc__},</div>
<div class="line">    {<span class="stringliteral">&quot;__deepcopy__&quot;</span>, (PyCFunction) <a class="code hl_function" href="binding_8c.html#ad5569e465c62a44515af6f4aa324fc60">py_bv_deepcopy</a>, METH_O,</div>
<div class="line">     py_bv_deepcopy__doc__},</div>
<div class="line">    {NULL, NULL, 0, NULL},</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a38c1503708121705e22921b48fabf14c"><div class="ttname"><a href="binding_8c.html#a38c1503708121705e22921b48fabf14c">py_bv_flip</a></div><div class="ttdeci">static PyObject * py_bv_flip(PyObject *self, PyObject *arg)</div><div class="ttdoc">Python binding for BitVector.flip(index).</div><div class="ttdef"><b>Definition</b> binding.c:306</div></div>
<div class="ttc" id="abinding_8c_html_a5a36766609fe6f9a6f7b436d305d29cd"><div class="ttname"><a href="binding_8c.html#a5a36766609fe6f9a6f7b436d305d29cd">py_bv_set_range</a></div><div class="ttdeci">static PyObject * py_bv_set_range(PyObject *self, PyObject *args)</div><div class="ttdoc">Python binding for BitVector.set_range(start, length).</div><div class="ttdef"><b>Definition</b> binding.c:330</div></div>
<div class="ttc" id="abinding_8c_html_a6596d7e4e07e24155651258c9091028b"><div class="ttname"><a href="binding_8c.html#a6596d7e4e07e24155651258c9091028b">py_bv_rank</a></div><div class="ttdeci">static PyObject * py_bv_rank(PyObject *self, PyObject *arg)</div><div class="ttdoc">Python binding for BitVector.rank(index) → bool.</div><div class="ttdef"><b>Definition</b> binding.c:395</div></div>
<div class="ttc" id="abinding_8c_html_a67c5804ed6745718be7527a3aae4664a"><div class="ttname"><a href="binding_8c.html#a67c5804ed6745718be7527a3aae4664a">py_bv_copy</a></div><div class="ttdeci">static PyObject * py_bv_copy(PyObject *self, PyObject *ignored)</div><div class="ttdoc">Python binding for BitVector.copy() → BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:120</div></div>
<div class="ttc" id="abinding_8c_html_a83289c5959b0cbc9ef594a00054b3d0a"><div class="ttname"><a href="binding_8c.html#a83289c5959b0cbc9ef594a00054b3d0a">py_bv_set</a></div><div class="ttdeci">static PyObject * py_bv_set(PyObject *self, PyObject *arg)</div><div class="ttdoc">Python binding for BitVector.set(index).</div><div class="ttdef"><b>Definition</b> binding.c:268</div></div>
<div class="ttc" id="abinding_8c_html_a95f4a245c9973679b1f9af1379e81821"><div class="ttname"><a href="binding_8c.html#a95f4a245c9973679b1f9af1379e81821">py_bv_get</a></div><div class="ttdeci">static PyObject * py_bv_get(PyObject *self, PyObject *arg)</div><div class="ttdoc">Python binding for BitVector.get(index) → bool.</div><div class="ttdef"><b>Definition</b> binding.c:250</div></div>
<div class="ttc" id="abinding_8c_html_abaa5a8a1af4ebbd29f13a650c21f3af2"><div class="ttname"><a href="binding_8c.html#abaa5a8a1af4ebbd29f13a650c21f3af2">py_bv_flip_range</a></div><div class="ttdeci">static PyObject * py_bv_flip_range(PyObject *self, PyObject *args)</div><div class="ttdoc">Python binding for BitVector.flip_range(start, length).</div><div class="ttdef"><b>Definition</b> binding.c:376</div></div>
<div class="ttc" id="abinding_8c_html_ac489bee1773936cb5e811e2d0252707f"><div class="ttname"><a href="binding_8c.html#ac489bee1773936cb5e811e2d0252707f">py_bv_clear_range</a></div><div class="ttdeci">static PyObject * py_bv_clear_range(PyObject *self, PyObject *args)</div><div class="ttdoc">Python binding for BitVector.clear_range(start, length).</div><div class="ttdef"><b>Definition</b> binding.c:353</div></div>
<div class="ttc" id="abinding_8c_html_ad5569e465c62a44515af6f4aa324fc60"><div class="ttname"><a href="binding_8c.html#ad5569e465c62a44515af6f4aa324fc60">py_bv_deepcopy</a></div><div class="ttdeci">static PyObject * py_bv_deepcopy(PyObject *self, PyObject *memo)</div><div class="ttdoc">Python binding for BitVector.__deepcopy__(memo) → BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:138</div></div>
<div class="ttc" id="abinding_8c_html_af3d93df3d5ac6faaa1366b7f31402798"><div class="ttname"><a href="binding_8c.html#af3d93df3d5ac6faaa1366b7f31402798">py_bv_clear</a></div><div class="ttdeci">static PyObject * py_bv_clear(PyObject *self, PyObject *arg)</div><div class="ttdoc">Python binding for BitVector.clear(index).</div><div class="ttdef"><b>Definition</b> binding.c:287</div></div>
</div><!-- fragment -->
<p>Method table for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> core methods. </p>

</div>
</div>
<a id="aaf11ef2595c77d036c93c64deed19ce2" name="aaf11ef2595c77d036c93c64deed19ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf11ef2595c77d036c93c64deed19ce2">&#9670;&#160;</a></span>cbits_module</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyModuleDef cbits_module</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .m_base = PyModuleDef_HEAD_INIT,</div>
<div class="line">    .m_name = <span class="stringliteral">&quot;_cbits&quot;</span>,</div>
<div class="line">    .m_doc = PyDoc_STR(<span class="stringliteral">&quot;cbits&quot;</span>),</div>
<div class="line">    .m_size = 0,</div>
<div class="line">    .m_slots = <a class="code hl_variable" href="binding_8c.html#a843c32fa48b7e83c731f95efec9e8b3f">cbits_module_slots</a>,</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a843c32fa48b7e83c731f95efec9e8b3f"><div class="ttname"><a href="binding_8c.html#a843c32fa48b7e83c731f95efec9e8b3f">cbits_module_slots</a></div><div class="ttdeci">static PyModuleDef_Slot cbits_module_slots[]</div><div class="ttdoc">Module initialization slots.</div><div class="ttdef"><b>Definition</b> binding.c:1600</div></div>
</div><!-- fragment -->
<p>Definition of the _cbits extension module. </p>
<p>Describes the module’s name, docstring, memory footprint, and its initialization slot table.</p>
<dl class="section see"><dt>See also</dt><dd>PyModuleDef </dd></dl>

</div>
</div>
<a id="a843c32fa48b7e83c731f95efec9e8b3f" name="a843c32fa48b7e83c731f95efec9e8b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843c32fa48b7e83c731f95efec9e8b3f">&#9670;&#160;</a></span>cbits_module_slots</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyModuleDef_Slot cbits_module_slots[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {Py_mod_exec, <a class="code hl_function" href="binding_8c.html#a8f427b0cfdb1957c3605e10019f007bd">cbits_module_exec</a>},</div>
<div class="line">    {0, NULL},</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a8f427b0cfdb1957c3605e10019f007bd"><div class="ttname"><a href="binding_8c.html#a8f427b0cfdb1957c3605e10019f007bd">cbits_module_exec</a></div><div class="ttdeci">static int cbits_module_exec(PyObject *module)</div><div class="ttdoc">Module exec callback: register BitVector type and metadata.</div><div class="ttdef"><b>Definition</b> binding.c:1528</div></div>
</div><!-- fragment -->
<p>Module initialization slots. </p>
<p>Lists callbacks invoked when the module is loaded; here, we use Py_mod_exec to register types and module constants.</p>
<dl class="section see"><dt>See also</dt><dd>PyModuleDef_Slot </dd></dl>

</div>
</div>
<a id="aed9d2206089523b6bc6fbac996e9895e" name="aed9d2206089523b6bc6fbac996e9895e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9d2206089523b6bc6fbac996e9895e">&#9670;&#160;</a></span>PyBitVector_getset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyGetSetDef PyBitVector_getset[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {<span class="stringliteral">&quot;bits&quot;</span>, (getter) <a class="code hl_function" href="binding_8c.html#a676b77aaaa3053d90f7ea7f95e22e8eb">py_bv_get_size</a>, (setter) <a class="code hl_function" href="binding_8c.html#a470ee7402be5662a9f0651631ec1f172">py_bv_set_size</a>,</div>
<div class="line">     PyDoc_STR(<span class="stringliteral">&quot;The number of bits&quot;</span>), NULL},</div>
<div class="line">    {NULL},</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a470ee7402be5662a9f0651631ec1f172"><div class="ttname"><a href="binding_8c.html#a470ee7402be5662a9f0651631ec1f172">py_bv_set_size</a></div><div class="ttdeci">static int py_bv_set_size(PyObject *self, void *closure)</div><div class="ttdoc">Setter for the read-only &quot;bits&quot; property, always raises.</div><div class="ttdef"><b>Definition</b> binding.c:1355</div></div>
<div class="ttc" id="abinding_8c_html_a676b77aaaa3053d90f7ea7f95e22e8eb"><div class="ttname"><a href="binding_8c.html#a676b77aaaa3053d90f7ea7f95e22e8eb">py_bv_get_size</a></div><div class="ttdeci">static PyObject * py_bv_get_size(PyObject *self, void *closure)</div><div class="ttdoc">Getter for the read-only &quot;bits&quot; property.</div><div class="ttdef"><b>Definition</b> binding.c:1342</div></div>
</div><!-- fragment -->
<p>Property definitions for the <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> type. </p>
<p>This table lists all read-only and writable properties exposed on the Python <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a> object.</p>
<dl class="section see"><dt>See also</dt><dd>PyGetSetDef </dd></dl>

</div>
</div>
<a id="a3c88cffd30f4952e8257b1cbe6571b27" name="a3c88cffd30f4952e8257b1cbe6571b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c88cffd30f4952e8257b1cbe6571b27">&#9670;&#160;</a></span>PyBitVector_slots</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyType_Slot PyBitVector_slots[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {Py_tp_doc, BitVector__doc__},</div>
<div class="line"> </div>
<div class="line">    {Py_tp_new, <a class="code hl_function" href="binding_8c.html#a33699ee8e583f6b69da8d7a4b011de12">py_bv_new</a>},</div>
<div class="line">    {Py_tp_init, <a class="code hl_function" href="binding_8c.html#a510d7b30401e3d3bd188a9a7de61803d">py_bv_init</a>},</div>
<div class="line">    {Py_tp_dealloc, <a class="code hl_function" href="binding_8c.html#a2d55c861d7fdf3b0e9b95497fdb6a6e4">py_bv_free</a>},</div>
<div class="line">    {Py_tp_methods, <a class="code hl_variable" href="binding_8c.html#a5bc423083838b34b1ff8c04a410a35e3">BitVector_methods</a>},</div>
<div class="line">    {Py_tp_repr, <a class="code hl_function" href="binding_8c.html#a7c29dda376c942eaafd3e1297c392b6c">py_bv_repr</a>},</div>
<div class="line">    {Py_tp_str, <a class="code hl_function" href="binding_8c.html#a08bbcefc5bea6072787075f0a7e305c8">py_bv_str</a>},</div>
<div class="line">    {Py_tp_getset, <a class="code hl_variable" href="binding_8c.html#aed9d2206089523b6bc6fbac996e9895e">PyBitVector_getset</a>},</div>
<div class="line">    {Py_tp_richcompare, <a class="code hl_function" href="binding_8c.html#a907d626799062d832d366b69aa7755ef">py_bv_richcompare</a>},</div>
<div class="line">    {Py_tp_hash, <a class="code hl_function" href="binding_8c.html#a2f67615df466f74b6f90c13dc37589ff">py_bv_hash</a>},</div>
<div class="line"> </div>
<div class="line">    {Py_tp_iter, <a class="code hl_function" href="binding_8c.html#a25220119ba92df39434d4868745481b1">py_bv_iter</a>},</div>
<div class="line">    {Py_mp_length, <a class="code hl_function" href="binding_8c.html#a21e08dec927792701cb73c6e6a1df927">py_bv_len</a>},</div>
<div class="line">    {Py_mp_subscript, <a class="code hl_function" href="binding_8c.html#a1a9db01fecf7acf29d81e6af54c2b1a1">py_bv_subscript</a>},</div>
<div class="line">    {Py_mp_ass_subscript, <a class="code hl_function" href="binding_8c.html#adde6296db3ce5161082498d618fda1ea">py_bv_ass_subscript</a>},</div>
<div class="line">    {Py_sq_contains, <a class="code hl_function" href="binding_8c.html#ac16b0c5b44b6cdd492918469bcbf7f96">py_bv_contains</a>},</div>
<div class="line"> </div>
<div class="line">    {Py_nb_and, <a class="code hl_function" href="binding_8c.html#a09bf92aec4a330bd6b0e0ad143f3ab36">py_bv_and</a>},</div>
<div class="line">    {Py_nb_inplace_and, <a class="code hl_function" href="binding_8c.html#ad100d02b61be2f9082ce249bc3099ddc">py_bv_iand</a>},</div>
<div class="line">    {Py_nb_or, <a class="code hl_function" href="binding_8c.html#ac80404db499e4bc108a6ac98bf2a117e">py_bv_or</a>},</div>
<div class="line">    {Py_nb_inplace_or, <a class="code hl_function" href="binding_8c.html#a2a23db722235b739cd8ca7af6aa096dd">py_bv_ior</a>},</div>
<div class="line">    {Py_nb_xor, <a class="code hl_function" href="binding_8c.html#aefe0bb25553ffc47f530cf93cb46ca42">py_bv_xor</a>},</div>
<div class="line">    {Py_nb_inplace_xor, <a class="code hl_function" href="binding_8c.html#a239e981d1a323d9bce7c018f08b5f081">py_bv_ixor</a>},</div>
<div class="line">    {Py_nb_invert, <a class="code hl_function" href="binding_8c.html#a21759f5b861d2e61454568931070553d">py_bv_invert</a>},</div>
<div class="line">    {Py_nb_bool, <a class="code hl_function" href="binding_8c.html#a2a48ec54bd2020b5f9c53ccb60efad9e">py_bv_bool</a>},</div>
<div class="line"> </div>
<div class="line">    {0, 0},</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a08bbcefc5bea6072787075f0a7e305c8"><div class="ttname"><a href="binding_8c.html#a08bbcefc5bea6072787075f0a7e305c8">py_bv_str</a></div><div class="ttdeci">static PyObject * py_bv_str(PyObject *self)</div><div class="ttdoc">str for BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:518</div></div>
<div class="ttc" id="abinding_8c_html_a09bf92aec4a330bd6b0e0ad143f3ab36"><div class="ttname"><a href="binding_8c.html#a09bf92aec4a330bd6b0e0ad143f3ab36">py_bv_and</a></div><div class="ttdeci">static PyObject * py_bv_and(PyObject *oA, PyObject *oB)</div><div class="ttdoc">and(BitVector, BitVector) → BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:1018</div></div>
<div class="ttc" id="abinding_8c_html_a1a9db01fecf7acf29d81e6af54c2b1a1"><div class="ttname"><a href="binding_8c.html#a1a9db01fecf7acf29d81e6af54c2b1a1">py_bv_subscript</a></div><div class="ttdeci">static PyObject * py_bv_subscript(PyObject *self, PyObject *arg)</div><div class="ttdoc">Implements BitVector.__getitem__ dispatch for index or slice.</div><div class="ttdef"><b>Definition</b> binding.c:688</div></div>
<div class="ttc" id="abinding_8c_html_a21759f5b861d2e61454568931070553d"><div class="ttname"><a href="binding_8c.html#a21759f5b861d2e61454568931070553d">py_bv_invert</a></div><div class="ttdeci">static PyObject * py_bv_invert(PyObject *self)</div><div class="ttdoc">invert(BitVector) → BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:1291</div></div>
<div class="ttc" id="abinding_8c_html_a21e08dec927792701cb73c6e6a1df927"><div class="ttname"><a href="binding_8c.html#a21e08dec927792701cb73c6e6a1df927">py_bv_len</a></div><div class="ttdeci">static Py_ssize_t py_bv_len(PyObject *self)</div><div class="ttdoc">len(BitVector) → number of bits.</div><div class="ttdef"><b>Definition</b> binding.c:589</div></div>
<div class="ttc" id="abinding_8c_html_a239e981d1a323d9bce7c018f08b5f081"><div class="ttname"><a href="binding_8c.html#a239e981d1a323d9bce7c018f08b5f081">py_bv_ixor</a></div><div class="ttdeci">static PyObject * py_bv_ixor(PyObject *self, PyObject *arg)</div><div class="ttdoc">ixor(BitVector, BitVector) in-place XOR.</div><div class="ttdef"><b>Definition</b> binding.c:1249</div></div>
<div class="ttc" id="abinding_8c_html_a25220119ba92df39434d4868745481b1"><div class="ttname"><a href="binding_8c.html#a25220119ba92df39434d4868745481b1">py_bv_iter</a></div><div class="ttdeci">static PyObject * py_bv_iter(PyObject *self)</div><div class="ttdoc">Create and return a new BitVector iterator.</div><div class="ttdef"><b>Definition</b> binding.c:989</div></div>
<div class="ttc" id="abinding_8c_html_a2a23db722235b739cd8ca7af6aa096dd"><div class="ttname"><a href="binding_8c.html#a2a23db722235b739cd8ca7af6aa096dd">py_bv_ior</a></div><div class="ttdeci">static PyObject * py_bv_ior(PyObject *self, PyObject *arg)</div><div class="ttdoc">ior(BitVector, BitVector) in-place OR.</div><div class="ttdef"><b>Definition</b> binding.c:1158</div></div>
<div class="ttc" id="abinding_8c_html_a2a48ec54bd2020b5f9c53ccb60efad9e"><div class="ttname"><a href="binding_8c.html#a2a48ec54bd2020b5f9c53ccb60efad9e">py_bv_bool</a></div><div class="ttdeci">static int py_bv_bool(PyObject *self)</div><div class="ttdoc">bool(BitVector) → boolean.</div><div class="ttdef"><b>Definition</b> binding.c:1325</div></div>
<div class="ttc" id="abinding_8c_html_a2d55c861d7fdf3b0e9b95497fdb6a6e4"><div class="ttname"><a href="binding_8c.html#a2d55c861d7fdf3b0e9b95497fdb6a6e4">py_bv_free</a></div><div class="ttdeci">static void py_bv_free(PyObject *self)</div><div class="ttdoc">Deallocate a PyBitVector object.</div><div class="ttdef"><b>Definition</b> binding.c:84</div></div>
<div class="ttc" id="abinding_8c_html_a2f67615df466f74b6f90c13dc37589ff"><div class="ttname"><a href="binding_8c.html#a2f67615df466f74b6f90c13dc37589ff">py_bv_hash</a></div><div class="ttdeci">static Py_hash_t py_bv_hash(PyObject *self)</div><div class="ttdoc">hash for a BitVector object.</div><div class="ttdef"><b>Definition</b> binding.c:560</div></div>
<div class="ttc" id="abinding_8c_html_a33699ee8e583f6b69da8d7a4b011de12"><div class="ttname"><a href="binding_8c.html#a33699ee8e583f6b69da8d7a4b011de12">py_bv_new</a></div><div class="ttdeci">static PyObject * py_bv_new(PyTypeObject *type, PyObject *args, PyObject *kwds)</div><div class="ttdoc">new for BitVector: allocate the Python object.</div><div class="ttdef"><b>Definition</b> binding.c:102</div></div>
<div class="ttc" id="abinding_8c_html_a510d7b30401e3d3bd188a9a7de61803d"><div class="ttname"><a href="binding_8c.html#a510d7b30401e3d3bd188a9a7de61803d">py_bv_init</a></div><div class="ttdeci">static int py_bv_init(PyObject *self, PyObject *args, PyObject *kwds)</div><div class="ttdoc">init for BitVector(size): allocate the underlying C BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:161</div></div>
<div class="ttc" id="abinding_8c_html_a5bc423083838b34b1ff8c04a410a35e3"><div class="ttname"><a href="binding_8c.html#a5bc423083838b34b1ff8c04a410a35e3">BitVector_methods</a></div><div class="ttdeci">static PyMethodDef BitVector_methods[]</div><div class="ttdoc">Method table for BitVector core methods.</div><div class="ttdef"><b>Definition</b> binding.c:475</div></div>
<div class="ttc" id="abinding_8c_html_a7c29dda376c942eaafd3e1297c392b6c"><div class="ttname"><a href="binding_8c.html#a7c29dda376c942eaafd3e1297c392b6c">py_bv_repr</a></div><div class="ttdeci">static PyObject * py_bv_repr(PyObject *self)</div><div class="ttdoc">repr for BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:505</div></div>
<div class="ttc" id="abinding_8c_html_a907d626799062d832d366b69aa7755ef"><div class="ttname"><a href="binding_8c.html#a907d626799062d832d366b69aa7755ef">py_bv_richcompare</a></div><div class="ttdeci">static PyObject * py_bv_richcompare(PyObject *a, PyObject *b, int op)</div><div class="ttdoc">Rich comparison (== and !=) for BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:533</div></div>
<div class="ttc" id="abinding_8c_html_ac16b0c5b44b6cdd492918469bcbf7f96"><div class="ttname"><a href="binding_8c.html#ac16b0c5b44b6cdd492918469bcbf7f96">py_bv_contains</a></div><div class="ttdeci">static int py_bv_contains(PyObject *self, PyObject *value)</div><div class="ttdoc">contains(BitVector, other) → boolean.</div><div class="ttdef"><b>Definition</b> binding.c:866</div></div>
<div class="ttc" id="abinding_8c_html_ac80404db499e4bc108a6ac98bf2a117e"><div class="ttname"><a href="binding_8c.html#ac80404db499e4bc108a6ac98bf2a117e">py_bv_or</a></div><div class="ttdeci">static PyObject * py_bv_or(PyObject *oA, PyObject *oB)</div><div class="ttdoc">or(BitVector, BitVector) → BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:1110</div></div>
<div class="ttc" id="abinding_8c_html_ad100d02b61be2f9082ce249bc3099ddc"><div class="ttname"><a href="binding_8c.html#ad100d02b61be2f9082ce249bc3099ddc">py_bv_iand</a></div><div class="ttdeci">static PyObject * py_bv_iand(PyObject *self, PyObject *arg)</div><div class="ttdoc">iand(BitVector, BitVector) in-place AND.</div><div class="ttdef"><b>Definition</b> binding.c:1066</div></div>
<div class="ttc" id="abinding_8c_html_adde6296db3ce5161082498d618fda1ea"><div class="ttname"><a href="binding_8c.html#adde6296db3ce5161082498d618fda1ea">py_bv_ass_subscript</a></div><div class="ttdeci">static int py_bv_ass_subscript(PyObject *self, PyObject *arg, PyObject *value)</div><div class="ttdoc">Implements BitVector.__setitem__ dispatch for index or slice.</div><div class="ttdef"><b>Definition</b> binding.c:825</div></div>
<div class="ttc" id="abinding_8c_html_aed9d2206089523b6bc6fbac996e9895e"><div class="ttname"><a href="binding_8c.html#aed9d2206089523b6bc6fbac996e9895e">PyBitVector_getset</a></div><div class="ttdeci">static PyGetSetDef PyBitVector_getset[]</div><div class="ttdoc">Property definitions for the BitVector type.</div><div class="ttdef"><b>Definition</b> binding.c:1369</div></div>
<div class="ttc" id="abinding_8c_html_aefe0bb25553ffc47f530cf93cb46ca42"><div class="ttname"><a href="binding_8c.html#aefe0bb25553ffc47f530cf93cb46ca42">py_bv_xor</a></div><div class="ttdeci">static PyObject * py_bv_xor(PyObject *oA, PyObject *oB)</div><div class="ttdoc">xor(BitVector, BitVector) → BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:1201</div></div>
</div><!-- fragment -->
<p>Slot table for the <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> type. </p>
<p>Maps Python’s type callbacks (new, init, dealloc, repr, etc.) and protocol slots (sequence, number, richcompare) to our C functions.</p>
<dl class="section see"><dt>See also</dt><dd>PyType_Slot </dd></dl>

</div>
</div>
<a id="a85cbcf7245043dda2766117451034a6c" name="a85cbcf7245043dda2766117451034a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cbcf7245043dda2766117451034a6c">&#9670;&#160;</a></span>PyBitVector_spec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyType_Spec PyBitVector_spec</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .name = <span class="stringliteral">&quot;cbits.BitVector&quot;</span>,</div>
<div class="line">    .basicsize = <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structPyBitVector.html">PyBitVector</a>),</div>
<div class="line">    .itemsize = 0,</div>
<div class="line">    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,</div>
<div class="line">    .slots = <a class="code hl_variable" href="binding_8c.html#a3c88cffd30f4952e8257b1cbe6571b27">PyBitVector_slots</a>,</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a3c88cffd30f4952e8257b1cbe6571b27"><div class="ttname"><a href="binding_8c.html#a3c88cffd30f4952e8257b1cbe6571b27">PyBitVector_slots</a></div><div class="ttdeci">static PyType_Slot PyBitVector_slots[]</div><div class="ttdoc">Slot table for the PyBitVector type.</div><div class="ttdef"><b>Definition</b> binding.c:1402</div></div>
<div class="ttc" id="astructPyBitVector_html"><div class="ttname"><a href="structPyBitVector.html">PyBitVector</a></div><div class="ttdoc">Python object containing a pointer to a native BitVector.</div><div class="ttdef"><b>Definition</b> binding.c:48</div></div>
</div><!-- fragment -->
<p>Type specification for <a class="el" href="structBitVector.html" title="Packed array of bits with support for rank/select operations.">BitVector</a>. </p>
<p>This structure describes the Python type name, size, inheritance flags, and slot table used to create the type.</p>
<dl class="section see"><dt>See also</dt><dd>PyType_Spec </dd></dl>

</div>
</div>
<a id="a5741aa05e43e6ec2d650341f5d4b1a0b" name="a5741aa05e43e6ec2d650341f5d4b1a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5741aa05e43e6ec2d650341f5d4b1a0b">&#9670;&#160;</a></span>PyBitVectorIter_slots</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyType_Slot PyBitVectorIter_slots[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    {Py_tp_dealloc, <a class="code hl_function" href="binding_8c.html#a881c976bd771094e5f63e77dbbacb95b">py_bviter_dealloc</a>},</div>
<div class="line">    {Py_tp_iter, PyObject_SelfIter},</div>
<div class="line">    {Py_tp_iternext, <a class="code hl_function" href="binding_8c.html#a778fdf5cc237723a965b88bf6011f519">py_bviter_iternext</a>},</div>
<div class="line">    {0, 0},</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a778fdf5cc237723a965b88bf6011f519"><div class="ttname"><a href="binding_8c.html#a778fdf5cc237723a965b88bf6011f519">py_bviter_iternext</a></div><div class="ttdeci">static PyObject * py_bviter_iternext(PyObject *self)</div><div class="ttdoc">Return the next bit as a Python boolean.</div><div class="ttdef"><b>Definition</b> binding.c:921</div></div>
<div class="ttc" id="abinding_8c_html_a881c976bd771094e5f63e77dbbacb95b"><div class="ttname"><a href="binding_8c.html#a881c976bd771094e5f63e77dbbacb95b">py_bviter_dealloc</a></div><div class="ttdeci">static void py_bviter_dealloc(PyObject *self)</div><div class="ttdoc">Deallocate a BitVector iterator object.</div><div class="ttdef"><b>Definition</b> binding.c:903</div></div>
</div><!-- fragment -->
<p>Slots for the _BitVectorIter type. </p>
<p>Defines deallocator, <b>iter</b> and <b>next</b>. </p>

</div>
</div>
<a id="a7f8cff07e2be78e6f372eab2796c7e66" name="a7f8cff07e2be78e6f372eab2796c7e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8cff07e2be78e6f372eab2796c7e66">&#9670;&#160;</a></span>PyBitVectorIter_spec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyType_Spec PyBitVectorIter_spec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .name = <span class="stringliteral">&quot;cbits._BitVectorIter&quot;</span>,</div>
<div class="line">    .basicsize = <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structPyBitVectorIter.html">PyBitVectorIter</a>),</div>
<div class="line">    .flags = Py_TPFLAGS_DEFAULT,</div>
<div class="line">    .slots = <a class="code hl_variable" href="binding_8c.html#a5741aa05e43e6ec2d650341f5d4b1a0b">PyBitVectorIter_slots</a>,</div>
<div class="line">}</div>
<div class="ttc" id="abinding_8c_html_a5741aa05e43e6ec2d650341f5d4b1a0b"><div class="ttname"><a href="binding_8c.html#a5741aa05e43e6ec2d650341f5d4b1a0b">PyBitVectorIter_slots</a></div><div class="ttdeci">static PyType_Slot PyBitVectorIter_slots[]</div><div class="ttdoc">Slots for the _BitVectorIter type.</div><div class="ttdef"><b>Definition</b> binding.c:957</div></div>
<div class="ttc" id="astructPyBitVectorIter_html"><div class="ttname"><a href="structPyBitVectorIter.html">PyBitVectorIter</a></div><div class="ttdoc">Iterator structure for PyBitVector.</div><div class="ttdef"><b>Definition</b> binding.c:884</div></div>
</div><!-- fragment -->
<p>Type specification for cbits._BitVectorIter. </p>
<p>This is the bit‐wise iterator returned by BitVector.__iter__(). </p>

</div>
</div>
<a id="ad5e8f8f4e20d3e7dec4041e7a9b47c1f" name="ad5e8f8f4e20d3e7dec4041e7a9b47c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e8f8f4e20d3e7dec4041e7a9b47c1f">&#9670;&#160;</a></span>PyBitVectorIterType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PyTypeObject* PyBitVectorIterType = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global pointer for the iterator type object </p>

</div>
</div>
<a id="a5625b28f722b33c1597cff28478aeb9a" name="a5625b28f722b33c1597cff28478aeb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5625b28f722b33c1597cff28478aeb9a">&#9670;&#160;</a></span>PyBitVectorPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyTypeObject* PyBitVectorPtr = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global pointer to the <a class="el" href="structPyBitVector.html" title="Python object containing a pointer to a native BitVector.">PyBitVector</a> type object. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 10 2025 09:30:03 for cbits by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
